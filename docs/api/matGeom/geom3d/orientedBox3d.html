<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of orientedBox3d</title>
  <meta name="keywords" content="orientedBox3d">
  <meta name="description" content="ORIENTEDBOX3D Object-oriented bounding box of a set of 3D points.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">geom3d</a> &gt; orientedBox3d.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\geom3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>orientedBox3d
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>ORIENTEDBOX3D Object-oriented bounding box of a set of 3D points.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [box3d, rotMat] = orientedBox3d(pts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">ORIENTEDBOX3D Object-oriented bounding box of a set of 3D points.

   OOBB = orientedBox3d(PTS)
   Returns the oriented bounding box of the collection of points in the
   N-by-3 array PTS. The result is given as:
   [XC YC ZC  L W H  PHI THETA PSI]
   where (XC,YC,ZC) corresponds to the center of the box, (L,W,H)
   corresponds to the length, width, and depth of the box, and (PHI,
   THETA, PSI) is the orientation of the box as Euler angles.

   [OOBB, ROT] = orientedBox3d(PTS)
   Also returns the rotation matrix of the point cloud, as a 3-by-3
   numeric array.

   Example
     [v, f] = sphereMesh;
     phi=-360+720*rand; theta=-360+720*rand; psi=-360+720*rand;
     angles = [phi, theta, psi];
     rotMat = eulerAnglesToRotation3d(angles);
     rotMat(1:3,4) = randi([-100,100],3,1);
     scale = [randi([7,9],1,1), randi([4,6],1,1), randi([1,3],1,1)];
     pts = transformPoint3d(bsxfun(@times, v, scale), rotMat);
     box3d = orientedBox3d(pts);
     figure; drawPoint3d(pts, '.'); 
     axis equal; xlabel('x'); ylabel('y'); zlabel('z');
     drawCuboid(box3d, 'FaceColor', 'none');

   See also
     meshes3d, <a href="drawCuboid.html" class="code" title="function varargout = drawCuboid(varargin)">drawCuboid</a>, <a href="rotation3dToEulerAngles.html" class="code" title="function varargout = rotation3dToEulerAngles(mat, varargin)">rotation3dToEulerAngles</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../matGeom/geom2d/createRotation.html" class="code" title="function trans = createRotation(varargin)">createRotation</a>	CREATEROTATION Create the 3*3 matrix of a rotation.</li><li><a href="../../matGeom/geom2d/createTranslation.html" class="code" title="function trans = createTranslation(varargin)">createTranslation</a>	CREATETRANSLATION Create the 3*3 matrix of a translation.</li><li><a href="../../matGeom/geom2d/orientedBox.html" class="code" title="function obox = orientedBox(points)">orientedBox</a>	ORIENTEDBOX Minimum-width oriented bounding box of a set of points.</li><li><a href="../../matGeom/geom2d/transformPoint.html" class="code" title="function varargout = transformPoint(varargin)">transformPoint</a>	TRANSFORMPOINT Apply an affine transform to a point or a point set.</li><li><a href="createPlane.html" class="code" title="function plane = createPlane(varargin)">createPlane</a>	CREATEPLANE Create a plane in parametrized form.</li><li><a href="crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>	CROSSPRODUCT3D Vector cross product faster than inbuilt MATLAB cross.</li><li><a href="distancePointPlane.html" class="code" title="function d = distancePointPlane(point, plane)">distancePointPlane</a>	DISTANCEPOINTPLANE Signed distance between 3D point and plane.</li><li><a href="normalizeVector3d.html" class="code" title="function vn = normalizeVector3d(v)">normalizeVector3d</a>	NORMALIZEVECTOR3D Normalize a 3D vector to have norm equal to 1.</li><li><a href="planePoint.html" class="code" title="function coord = planePoint(plane, point)">planePoint</a>	PLANEPOINT Compute 3D position of a point in a plane.</li><li><a href="planePosition.html" class="code" title="function [pos, zp] = planePosition(point, plane)">planePosition</a>	PLANEPOSITION Compute position of a point on a plane.</li><li><a href="projPointOnPlane.html" class="code" title="function point = projPointOnPlane(point, plane)">projPointOnPlane</a>	PROJPOINTONPLANE Return the orthogonal projection of a point on a plane.</li><li><a href="rotation3dToEulerAngles.html" class="code" title="function varargout = rotation3dToEulerAngles(mat, varargin)">rotation3dToEulerAngles</a>	ROTATION3DTOEULERANGLES Extract Euler angles from a rotation matrix.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [box3d, rotMat] = orientedBox3d(pts)</a>
0002 <span class="comment">%ORIENTEDBOX3D Object-oriented bounding box of a set of 3D points.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   OOBB = orientedBox3d(PTS)</span>
0005 <span class="comment">%   Returns the oriented bounding box of the collection of points in the</span>
0006 <span class="comment">%   N-by-3 array PTS. The result is given as:</span>
0007 <span class="comment">%   [XC YC ZC  L W H  PHI THETA PSI]</span>
0008 <span class="comment">%   where (XC,YC,ZC) corresponds to the center of the box, (L,W,H)</span>
0009 <span class="comment">%   corresponds to the length, width, and depth of the box, and (PHI,</span>
0010 <span class="comment">%   THETA, PSI) is the orientation of the box as Euler angles.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   [OOBB, ROT] = orientedBox3d(PTS)</span>
0013 <span class="comment">%   Also returns the rotation matrix of the point cloud, as a 3-by-3</span>
0014 <span class="comment">%   numeric array.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   Example</span>
0017 <span class="comment">%     [v, f] = sphereMesh;</span>
0018 <span class="comment">%     phi=-360+720*rand; theta=-360+720*rand; psi=-360+720*rand;</span>
0019 <span class="comment">%     angles = [phi, theta, psi];</span>
0020 <span class="comment">%     rotMat = eulerAnglesToRotation3d(angles);</span>
0021 <span class="comment">%     rotMat(1:3,4) = randi([-100,100],3,1);</span>
0022 <span class="comment">%     scale = [randi([7,9],1,1), randi([4,6],1,1), randi([1,3],1,1)];</span>
0023 <span class="comment">%     pts = transformPoint3d(bsxfun(@times, v, scale), rotMat);</span>
0024 <span class="comment">%     box3d = orientedBox3d(pts);</span>
0025 <span class="comment">%     figure; drawPoint3d(pts, '.');</span>
0026 <span class="comment">%     axis equal; xlabel('x'); ylabel('y'); zlabel('z');</span>
0027 <span class="comment">%     drawCuboid(box3d, 'FaceColor', 'none');</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%   See also</span>
0030 <span class="comment">%     meshes3d, drawCuboid, rotation3dToEulerAngles</span>
0031 
0032 <span class="comment">% ------</span>
0033 <span class="comment">% Author: David Legland</span>
0034 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0035 <span class="comment">% Created: 2015-12-01, using Matlab 8.6.0.267246 (R2015b)</span>
0036 <span class="comment">% Copyright 2015-2024 INRA - Cepia Software Platform</span>
0037 
0038 tri = convhulln(pts);
0039 nFaces = size(tri, 1);
0040 
0041 <span class="comment">%% identify index of face with smallest width</span>
0042 indMinBreadth = 0;
0043 minBreadth = Inf;
0044 <span class="keyword">for</span> iFace = 1:nFaces
0045     faceInds = tri(iFace, :);
0046     plane = <a href="createPlane.html" class="code" title="function plane = createPlane(varargin)">createPlane</a>(pts(faceInds, :));
0047     
0048     breadth = max(abs(<a href="distancePointPlane.html" class="code" title="function d = distancePointPlane(point, plane)">distancePointPlane</a>(pts, plane)));
0049     
0050     <span class="keyword">if</span> breadth &lt; minBreadth
0051         minBreadth = breadth;
0052         indMinBreadth = iFace;
0053     <span class="keyword">end</span>
0054 <span class="keyword">end</span>
0055 
0056 <span class="comment">% compute projection on reference plane</span>
0057 refPlane = <a href="createPlane.html" class="code" title="function plane = createPlane(varargin)">createPlane</a>(pts(tri(indMinBreadth, :), :));
0058 pts2d = <a href="planePosition.html" class="code" title="function [pos, zp] = planePosition(point, plane)">planePosition</a>(<a href="projPointOnPlane.html" class="code" title="function point = projPointOnPlane(point, plane)">projPointOnPlane</a>(pts, refPlane), refPlane);
0059 
0060 <span class="comment">% compute 2D OOBB for projected points</span>
0061 box2d = <a href="../../matGeom/geom2d/orientedBox.html" class="code" title="function obox = orientedBox(points)">orientedBox</a>(pts2d);
0062 
0063 <span class="comment">% extract reference points from planar OOBB: the center, and two direction</span>
0064 <span class="comment">% vectors</span>
0065 center2d = box2d(1:2);
0066 L1 = box2d(3);
0067 L2 = box2d(4);
0068 markers2d = [0 0; L1/2 0; 0 L2/2];
0069 
0070 <span class="comment">% orient reference points to 2d basis</span>
0071 theta2d = box2d(5);
0072 rot = <a href="../../matGeom/geom2d/createRotation.html" class="code" title="function trans = createRotation(varargin)">createRotation</a>(deg2rad(theta2d));
0073 tra = <a href="../../matGeom/geom2d/createTranslation.html" class="code" title="function trans = createTranslation(varargin)">createTranslation</a>(center2d);
0074 transfo = tra * rot;
0075 markers2d = <a href="../../matGeom/geom2d/transformPoint.html" class="code" title="function varargout = transformPoint(varargin)">transformPoint</a>(markers2d, transfo);
0076 
0077 <span class="comment">% backprojection to 3D space</span>
0078 markers3d = <a href="planePoint.html" class="code" title="function coord = planePoint(plane, point)">planePoint</a>(refPlane, markers2d);
0079 
0080 <span class="comment">% compute 3D vectors and center</span>
0081 centerProj = markers3d(1,:);
0082 v1n = <a href="normalizeVector3d.html" class="code" title="function vn = normalizeVector3d(v)">normalizeVector3d</a>(markers3d(2,:) - centerProj);
0083 v2n = <a href="normalizeVector3d.html" class="code" title="function vn = normalizeVector3d(v)">normalizeVector3d</a>(markers3d(3,:) - centerProj);
0084 
0085 <span class="comment">% compute rotation matrix and convert to Euler Angles</span>
0086 v3n = <a href="crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>(v1n, v2n);
0087 rotMat = [v1n' v2n' v3n'];
0088 boxAngles = <a href="rotation3dToEulerAngles.html" class="code" title="function varargout = rotation3dToEulerAngles(mat, varargin)">rotation3dToEulerAngles</a>(rotMat);
0089 
0090 <span class="comment">% create 3D object-oriented bounding box</span>
0091 boxCenter3d = centerProj + v3n * minBreadth/2;
0092 box3d = [boxCenter3d L1 L2 minBreadth boxAngles];</pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>