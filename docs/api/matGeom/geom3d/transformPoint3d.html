<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of transformPoint3d</title>
  <meta name="keywords" content="transformPoint3d">
  <meta name="description" content="TRANSFORMPOINT3D Transform a point with a 3D affine transform.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">geom3d</a> &gt; transformPoint3d.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\geom3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>transformPoint3d
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>TRANSFORMPOINT3D Transform a point with a 3D affine transform.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function varargout = transformPoint3d(pts, transfo, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">TRANSFORMPOINT3D Transform a point with a 3D affine transform.

   PT2 = transformPoint3d(PT1, TRANS);
   PT2 = transformPoint3d(X1, Y1, Z1, TRANS);
   where PT1 has the form [xp yp zp], and TRANS is a 3-by-3, 3-by-4, or
   4-by-4 matrix, returns the point transformed according to the affine
   transform specified by TRANS.

   The function accepts transforms given using the following formats:
   [a b c]   ,   [a b c j] , or [a b c j]
   [d e f]       [d e f k]      [d e f k]
   [g h i]       [g h i l]      [g h i l]
                                [0 0 0 1]

   PT2 = transformPoint3d(PT1, TRANS) 
   also work when PT1 is a N-by-3-by-M-by-P-by-ETC array of double. In
   this case, PT2 has the same size as PT1.

   PT2 = transformPoint3d(X1, Y1, Z1, TRANS);
   also work when X1, Y1 and Z1 are 3 arrays with the same size. In this
   case, PT2 will be a 1-by-3 cell containing {X Y Z} outputs of size(X1).

   [X2, Y2, Z2] = transformPoint3d(...);
   returns the result in 3 different arrays the same size as the input.
   This form can be useful when used with functions like meshgrid or warp.
   
   MESH2 = transformPoint3d(MESH, TRANS) 
   transforms the field 'vertices' of the struct MESH and returns the same
   struct with the transformed vertices.
   (It is recommended to use the function 'transformMesh', within the
   &quot;meshes3d&quot; module). 

   See also
     <a href="points3d.html" class="code" title="function points3d(varargin)">points3d</a>, <a href="transforms3d.html" class="code" title="function transforms3d(varargin)">transforms3d</a>, transformMesh, <a href="createTranslation3d.html" class="code" title="function trans = createTranslation3d(varargin)">createTranslation3d</a>
     <a href="createRotationOx.html" class="code" title="function trans = createRotationOx(varargin)">createRotationOx</a>, <a href="createRotationOy.html" class="code" title="function trans = createRotationOy(varargin)">createRotationOy</a>, <a href="createRotationOz.html" class="code" title="function trans = createRotationOz(varargin)">createRotationOz</a>, createScaling</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="transformPoint3d.html" class="code" title="function varargout = transformPoint3d(pts, transfo, varargin)">transformPoint3d</a>	TRANSFORMPOINT3D Transform a point with a 3D affine transform.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../matGeom/geom2d/principalAxesTransform.html" class="code" title="function varargout = principalAxesTransform(pts)">principalAxesTransform</a>	PRINCIPALAXESTRANSFORM Align a set of points along its principal axes.</li><li><a href="circle3dOrigin.html" class="code" title="function ori = circle3dOrigin(varargin)">circle3dOrigin</a>	CIRCLE3DORIGIN Return the first point of a 3D circle.</li><li><a href="circle3dPoint.html" class="code" title="function point = circle3dPoint(circle, pos)">circle3dPoint</a>	CIRCLE3DPOINT Coordinates of a point on a 3D circle from its position.</li><li><a href="clipPolygonByPlane3d.html" class="code" title="function poly2 = clipPolygonByPlane3d(poly, plane, varargin)">clipPolygonByPlane3d</a>	CLIPPOLYGONBYPLANE3D Clip a 3D polygon with a plane.</li><li><a href="createBasisTransform3d.html" class="code" title="function transfo = createBasisTransform3d(source, target)">createBasisTransform3d</a>	CREATEBASISTRANSFORM3D Compute matrix for transforming a basis into another basis.</li><li><a href="drawArrow3d.html" class="code" title="function varargout = drawArrow3d(varargin)">drawArrow3d</a>	DRAWARROW3D Plot a quiver of 3D arrows.</li><li><a href="drawAxis3d.html" class="code" title="function varargout = drawAxis3d(varargin)">drawAxis3d</a>	DRAWAXIS3D Draw a coordinate system and an origin.</li><li><a href="drawCircle3d.html" class="code" title="function varargout = drawCircle3d(varargin)">drawCircle3d</a>	DRAWCIRCLE3D Draw a 3D circle.</li><li><a href="drawCircleArc3d.html" class="code" title="function varargout = drawCircleArc3d(varargin)">drawCircleArc3d</a>	DRAWCIRCLEARC3D Draw a 3D circle arc.</li><li><a href="drawCube.html" class="code" title="function varargout = drawCube(varargin)">drawCube</a>	DRAWCUBE Draw a 3D centered cube, eventually rotated.</li><li><a href="drawCuboid.html" class="code" title="function varargout = drawCuboid(varargin)">drawCuboid</a>	DRAWCUBOID Draw a 3D cuboid, eventually rotated.</li><li><a href="drawCylinder.html" class="code" title="function varargout = drawCylinder(varargin)">drawCylinder</a>	DRAWCYLINDER Draw a cylinder.</li><li><a href="drawEllipse3d.html" class="code" title="function varargout = drawEllipse3d(varargin)">drawEllipse3d</a>	DRAWELLIPSE3D Draw a 3D ellipse.</li><li><a href="drawEllipseCylinder.html" class="code" title="function varargout = drawEllipseCylinder(varargin)">drawEllipseCylinder</a>	DRAWELLIPSECYLINDER Draw a cylinder with ellipse cross-section.</li><li><a href="drawEllipsoid.html" class="code" title="function varargout = drawEllipsoid(varargin)">drawEllipsoid</a>	DRAWELLIPSOID Draw a 3D ellipsoid.</li><li><a href="drawTorus.html" class="code" title="function varargout = drawTorus(varargin)">drawTorus</a>	DRAWTORUS Draw a torus (3D ring).</li><li><a href="fitCircle3d.html" class="code" title="function [fittedCircle, circleNormal, residuals] = fitCircle3d(pts, varargin)">fitCircle3d</a>	FITCIRCLE3D Fit a 3D circle to a set of points.</li><li><a href="fitEllipse3d.html" class="code" title="function [fittedEllipse3d, TFM3D] = fitEllipse3d(points, varargin)">fitEllipse3d</a>	FITELLIPSE3D Fit an ellipse to a set of points.</li><li><a href="geodesicCylinder.html" class="code" title="function [geo, geoLength, conGeo, conGeoLength] = geodesicCylinder(pts, cyl, varargin)">geodesicCylinder</a>	GEODESICCYLINDER Computes the geodesic between two points on a cylinder.</li><li><a href="isPointInEllipsoid.html" class="code" title="function b = isPointInEllipsoid(point, elli, varargin)">isPointInEllipsoid</a>	ISPOINTINELLIPSOID Check if a point is located inside a 3D ellipsoid.</li><li><a href="projPointOnCylinder.html" class="code" title="function ptProj = projPointOnCylinder(pt, cyl, varargin)">projPointOnCylinder</a>	PROJPOINTONCYLINDER Project a 3D point onto a cylinder.</li><li><a href="registerPoints3d_affine.html" class="code" title="function [trans, points] = registerPoints3d_affine(points, target, varargin)">registerPoints3d_affine</a>	registerPoints3d_affine Fit 3D affine transform using iterative algorithm.</li><li><a href="registerPoints3d_icp.html" class="code" title="function [transfo, pt, ER, t] = registerPoints3d_icp(p, q, varargin)">registerPoints3d_icp</a>	REGISTERPOINTS3D_ICP Computes rigid transform between two 3D point sets.</li><li><a href="transformCircle3d.html" class="code" title="function circle2 = transformCircle3d(circle, tfm)">transformCircle3d</a>	TRANSFORMCIRCLE3D Transform a 3D circle with a 3D affine transformation.</li><li><a href="transformLine3d.html" class="code" title="function res = transformLine3d(line, trans)">transformLine3d</a>	TRANSFORMLINE3D Transform a 3D line with a 3D affine transform.</li><li><a href="transformPlane3d.html" class="code" title="function plane2 = transformPlane3d(plane, trans)">transformPlane3d</a>	TRANSFORMPLANE3D Transform a 3D plane with a 3D affine transform.</li><li><a href="transformPoint3d.html" class="code" title="function varargout = transformPoint3d(pts, transfo, varargin)">transformPoint3d</a>	TRANSFORMPOINT3D Transform a point with a 3D affine transform.</li><li><a href="transformPolygon3d.html" class="code" title="function tfmPoly = transformPolygon3d(poly, tfm)">transformPolygon3d</a>	TRANSFORMPOLYGON3D Transform a polygon with a 3D affine transform.</li><li><a href="transformVector3d.html" class="code" title="function varargout = transformVector3d(varargin)">transformVector3d</a>	TRANSFORMVECTOR3D Transform a vector with a 3D affine transform.</li><li><a href="../../matGeom/meshes3d/circleMesh.html" class="code" title="function varargout = circleMesh(circle, varargin)">circleMesh</a>	CIRCLEMESH Create a mesh defined by a 3D circle.</li><li><a href="../../matGeom/meshes3d/createDurerPolyhedron.html" class="code" title="function varargout = createDurerPolyhedron(varargin)">createDurerPolyhedron</a>	CREATEDURERPOLYHEDRON  Create a mesh representing Durer's polyhedron .</li><li><a href="../../matGeom/meshes3d/curveToMesh.html" class="code" title="function [vertices, faces] = curveToMesh(curve, varargin)">curveToMesh</a>	CURVETOMESH Create a mesh surrounding a 3D curve.</li><li><a href="../../matGeom/meshes3d/cylinderMesh.html" class="code" title="function varargout = cylinderMesh(cyl, varargin)">cylinderMesh</a>	CYLINDERMESH Create a 3D mesh representing a cylinder.</li><li><a href="../../matGeom/meshes3d/ellipsoidMesh.html" class="code" title="function varargout = ellipsoidMesh(elli, varargin)">ellipsoidMesh</a>	ELLIPSOIDMESH Convert a 3D ellipsoid to face-vertex mesh representation.</li><li><a href="../../matGeom/meshes3d/meshSilhouette.html" class="code" title="function silhouette = meshSilhouette(v, f, varargin)">meshSilhouette</a>	MESHSILHOUETTE Compute the 2D outline of a 3D mesh on an arbitrary plane.</li><li><a href="../../matGeom/meshes3d/torusMesh.html" class="code" title="function varargout = torusMesh(torus, varargin)">torusMesh</a>	TORUSMESH Create a 3D mesh representing a torus.</li><li><a href="../../matGeom/meshes3d/transformMesh.html" class="code" title="function varargout = transformMesh(varargin)">transformMesh</a>	TRANSFORMMESH Applies a 3D affine transform to a mesh.</li><li><a href="../../matGeom/meshes3d/triangulatePolygonPair.html" class="code" title="function [vertices, faces] = triangulatePolygonPair(poly1, poly2, varargin)">triangulatePolygonPair</a>	TRIANGULATEPOLYGONPAIR Compute triangulation between a pair of 3D closed curves.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = transformPoint3d(pts, transfo, varargin)</a>
0002 <span class="comment">%TRANSFORMPOINT3D Transform a point with a 3D affine transform.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   PT2 = transformPoint3d(PT1, TRANS);</span>
0005 <span class="comment">%   PT2 = transformPoint3d(X1, Y1, Z1, TRANS);</span>
0006 <span class="comment">%   where PT1 has the form [xp yp zp], and TRANS is a 3-by-3, 3-by-4, or</span>
0007 <span class="comment">%   4-by-4 matrix, returns the point transformed according to the affine</span>
0008 <span class="comment">%   transform specified by TRANS.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   The function accepts transforms given using the following formats:</span>
0011 <span class="comment">%   [a b c]   ,   [a b c j] , or [a b c j]</span>
0012 <span class="comment">%   [d e f]       [d e f k]      [d e f k]</span>
0013 <span class="comment">%   [g h i]       [g h i l]      [g h i l]</span>
0014 <span class="comment">%                                [0 0 0 1]</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   PT2 = transformPoint3d(PT1, TRANS)</span>
0017 <span class="comment">%   also work when PT1 is a N-by-3-by-M-by-P-by-ETC array of double. In</span>
0018 <span class="comment">%   this case, PT2 has the same size as PT1.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   PT2 = transformPoint3d(X1, Y1, Z1, TRANS);</span>
0021 <span class="comment">%   also work when X1, Y1 and Z1 are 3 arrays with the same size. In this</span>
0022 <span class="comment">%   case, PT2 will be a 1-by-3 cell containing {X Y Z} outputs of size(X1).</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   [X2, Y2, Z2] = transformPoint3d(...);</span>
0025 <span class="comment">%   returns the result in 3 different arrays the same size as the input.</span>
0026 <span class="comment">%   This form can be useful when used with functions like meshgrid or warp.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   MESH2 = transformPoint3d(MESH, TRANS)</span>
0029 <span class="comment">%   transforms the field 'vertices' of the struct MESH and returns the same</span>
0030 <span class="comment">%   struct with the transformed vertices.</span>
0031 <span class="comment">%   (It is recommended to use the function 'transformMesh', within the</span>
0032 <span class="comment">%   &quot;meshes3d&quot; module).</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%   See also</span>
0035 <span class="comment">%     points3d, transforms3d, transformMesh, createTranslation3d</span>
0036 <span class="comment">%     createRotationOx, createRotationOy, createRotationOz, createScaling</span>
0037 <span class="comment">%</span>
0038 
0039 <span class="comment">% ------</span>
0040 <span class="comment">% Author: David Legland</span>
0041 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0042 <span class="comment">% Created: 2005-02-10</span>
0043 <span class="comment">% Copyright 2005-2024 INRA - TPV URPOI - BIA IMASTE</span>
0044 
0045 <span class="comment">%% Parse input arguments</span>
0046 
0047 <span class="comment">% Check special case: if first argument is a struct with a field named</span>
0048 <span class="comment">% 'vertices', then the output will be the same struct, but with the</span>
0049 <span class="comment">% transformed vertices.</span>
0050 <span class="keyword">if</span> nargin == 2 &amp;&amp; isstruct(pts) &amp;&amp; isfield(pts, <span class="string">'vertices'</span>)
0051     mesh = pts;
0052     mesh.vertices = <a href="transformPoint3d.html" class="code" title="function varargout = transformPoint3d(pts, transfo, varargin)">transformPoint3d</a>(mesh.vertices, transfo);
0053     varargout = {mesh};
0054     <span class="keyword">return</span>;
0055 <span class="keyword">end</span>
0056 
0057 <span class="comment">% Parse x, y, and z coordinates of input points from input arguments</span>
0058 <span class="keyword">if</span> nargin == 2
0059     <span class="comment">% Point coordinates are given in a single N-by-3-by-M-by-etc argument.</span>
0060     <span class="comment">% Preallocate x, y, and z to size N-by-1-by-M-by-etc, then fill them in</span>
0061     dim = size(pts);
0062     dim(2) = 1;
0063     [x, y, z] = deal(zeros(dim, class(pts)));
0064     x(:) = pts(:,1,:);
0065     y(:) = pts(:,2,:);
0066     z(:) = pts(:,3,:);
0067     
0068 <span class="keyword">elseif</span> nargin == 4
0069     <span class="comment">% Point coordinates are given in 3 different arrays</span>
0070     x = pts;
0071     y = transfo;
0072     z = varargin{1};
0073     transfo = varargin{2};
0074     dim = size(x);
0075     
0076 <span class="keyword">else</span>
0077     error(<span class="string">'MatGeom:geom3d:WrongInputArgumentNumber'</span>, <span class="keyword">...</span>
0078         <span class="string">'Requires number of input arguments to be either 2 or 4'</span>);
0079 <span class="keyword">end</span>
0080 
0081 
0082 <span class="comment">%% Process transformation matrix</span>
0083 
0084 <span class="comment">% extract the linear and the translation parts of the matrix</span>
0085 linear = transfo(1:3, 1:3)';
0086 trans = [0 0 0];
0087 <span class="keyword">if</span> size(transfo, 2) &gt; 3
0088     trans = transfo(1:3, 4)';
0089 <span class="keyword">end</span>
0090 
0091 
0092 <span class="comment">%% Main processing</span>
0093 
0094 <span class="comment">% convert coordinates</span>
0095 <span class="keyword">try</span>
0096     <span class="comment">% vectorial processing, if there is enough memory.</span>
0097     <span class="comment">% same as:</span>
0098     <span class="comment">% res = (transfo * [x(:) y(:) z(:) ones(NP, 1)]')';</span>
0099     res = bsxfun(@plus, [x(:) y(:) z(:)] * linear, trans);
0100     
0101     <span class="comment">% Back-fill x,y,z with new result (saves calling costly reshape())</span>
0102     x(:) = res(:,1);
0103     y(:) = res(:,2);
0104     z(:) = res(:,3);
0105     
0106 <span class="keyword">catch</span> ME
0107     disp(ME.message)
0108     <span class="comment">% process each point one by one, writing in existing array</span>
0109     NP = numel(x);
0110     <span class="keyword">for</span> i = 1:NP
0111         res = [x(i) y(i) z(i)] * linear + trans;
0112         x(i) = res(1);
0113         y(i) = res(2);
0114         z(i) = res(3);
0115     <span class="keyword">end</span>
0116 <span class="keyword">end</span>
0117 
0118 <span class="comment">% process output arguments</span>
0119 <span class="keyword">if</span> nargout &lt;= 1
0120     <span class="comment">% results are stored in a unique array</span>
0121     <span class="keyword">if</span> length(dim) &gt; 2 &amp;&amp; dim(2) &gt; 1
0122         warning(<span class="string">'geom3d:shapeMismatch'</span>,<span class="keyword">...</span>
0123             <span class="string">'Shape mismatch: Non-vector xyz input should have multiple x,y,z output arguments. Cell {x,y,z} returned instead.'</span>)
0124         varargout{1} = {x,y,z};
0125     <span class="keyword">else</span>
0126         varargout{1} = [x y z];
0127     <span class="keyword">end</span>
0128     
0129 <span class="keyword">elseif</span> nargout == 3
0130     <span class="comment">% results are returned in three array with same size.</span>
0131     varargout = {x, y, z};
0132 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>