<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of prim_mst</title>
  <meta name="keywords" content="prim_mst">
  <meta name="description" content="PRIM_MST Minimal spanning tree by Prim's algorithm.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">graphs</a> &gt; prim_mst.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\graphs&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>prim_mst
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>PRIM_MST Minimal spanning tree by Prim's algorithm.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function varargout = prim_mst(edges, vals) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">PRIM_MST Minimal spanning tree by Prim's algorithm.

   EDGES2 = prim_mst(EDGES, WEIGHTS)
   Compute the minimal spanning tree (MST) of the graph with edges given
   by EDGES, and using the specified edge weights.
   The nodes of the resulting tree are the same as the nodes of the
   original graph. Therefore, the function requires only to specify edges.

   Example
     pts = load('sedgewick_points.txt');
     [nodes, edges] = delaunayGraph(pts);
     figure; drawGraphEdges(nodes, edges, 'color', 'k');
     axis equal; axis([10 27 10 27]); hold on;
     weights = grEdgeLengths(nodes, edges);
     edges2 = prim_mst(edges, weights);
     drawGraphEdges(nodes, edges2, 'linewidth', 2, 'color', 'b');
   
   See also
     <a href="euclideanMST.html" class="code" title="function varargout = euclideanMST(points)">euclideanMST</a>, <a href="grEdgeLengths.html" class="code" title="function lengths = grEdgeLengths(nodes, edges, varargin)">grEdgeLengths</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="euclideanMST.html" class="code" title="function varargout = euclideanMST(points)">euclideanMST</a>	EUCLIDEANMST Build euclidean minimal spanning tree of a set of points.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = prim_mst(edges, vals)</a>
0002 <span class="comment">%PRIM_MST Minimal spanning tree by Prim's algorithm.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   EDGES2 = prim_mst(EDGES, WEIGHTS)</span>
0005 <span class="comment">%   Compute the minimal spanning tree (MST) of the graph with edges given</span>
0006 <span class="comment">%   by EDGES, and using the specified edge weights.</span>
0007 <span class="comment">%   The nodes of the resulting tree are the same as the nodes of the</span>
0008 <span class="comment">%   original graph. Therefore, the function requires only to specify edges.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   Example</span>
0011 <span class="comment">%     pts = load('sedgewick_points.txt');</span>
0012 <span class="comment">%     [nodes, edges] = delaunayGraph(pts);</span>
0013 <span class="comment">%     figure; drawGraphEdges(nodes, edges, 'color', 'k');</span>
0014 <span class="comment">%     axis equal; axis([10 27 10 27]); hold on;</span>
0015 <span class="comment">%     weights = grEdgeLengths(nodes, edges);</span>
0016 <span class="comment">%     edges2 = prim_mst(edges, weights);</span>
0017 <span class="comment">%     drawGraphEdges(nodes, edges2, 'linewidth', 2, 'color', 'b');</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   See also</span>
0020 <span class="comment">%     euclideanMST, grEdgeLengths</span>
0021 <span class="comment">%</span>
0022 
0023 <span class="comment">% ------</span>
0024 <span class="comment">% Author: David Legland</span>
0025 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0026 <span class="comment">% Created: 2007-07-27, using Matlab 7.4.0.287 (R2007a)</span>
0027 <span class="comment">% Copyright 2007-2024 INRA - BIA PV Nantes - MIAJ Jouy-en-Josas</span>
0028 
0029 <span class="comment">% isolate vertices index</span>
0030 nodes   = unique(edges(:));
0031 N       = length(nodes);
0032 
0033 <span class="comment">% initialize memory</span>
0034 nodes2  = zeros(N, 1);
0035 edges2  = zeros(N-1, 2);
0036 vals2   = zeros(N-1, 1);
0037 
0038 <span class="comment">% initialize with a first node</span>
0039 nodes2(1)   = nodes(1);
0040 nodes       = nodes(2:end);
0041 
0042 <span class="comment">% iterate on edges</span>
0043 <span class="keyword">for</span> i = 1:N-1
0044     <span class="comment">% find all edges from nodes2 to nodes</span>
0045     ind = unique(find(<span class="keyword">...</span>
0046         (ismember(edges(:,1), nodes2(1:i)) &amp; ismember(edges(:,2), nodes)) | <span class="keyword">...</span>
0047         (ismember(edges(:,1), nodes) &amp; ismember(edges(:,2), nodes2(1:i))) ));
0048     
0049     <span class="comment">% choose edge with lowest value</span>
0050     [tmp, ind2] = min(vals(ind)); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0051     ind = ind(ind2(1));
0052     vals2(i) = vals(ind);
0053     
0054     <span class="comment">% index of other vertex</span>
0055     edge    = edges(ind, :);
0056     neigh   = edge(~ismember(edge, nodes2));
0057     
0058     <span class="comment">% add to list of nodes and list of edges</span>
0059     nodes2(i+1) = neigh;
0060     edges2(i,:) = edge;
0061     
0062     <span class="comment">% remove current node from list of old nodes</span>
0063     nodes   = nodes(~ismember(nodes, neigh));
0064 <span class="keyword">end</span>
0065 
0066 
0067 <span class="comment">% process output arguments</span>
0068 <span class="keyword">if</span> nargout == 1
0069     varargout{1} = edges2;
0070 <span class="keyword">elseif</span> nargout==2
0071     varargout{1} = edges2;
0072     varargout{2} = vals2;
0073 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>