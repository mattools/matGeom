<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of readMesh_ply</title>
  <meta name="keywords" content="readMesh_ply">
  <meta name="description" content="READMESH_PLY Read mesh data stored in PLY (Stanford triangle) format.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">meshes3d</a> &gt; readMesh_ply.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\meshes3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>readMesh_ply
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>READMESH_PLY Read mesh data stored in PLY (Stanford triangle) format.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function varargout = readMesh_ply(fileName) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">READMESH_PLY Read mesh data stored in PLY (Stanford triangle) format.

   [V, F] = readMesh_ply(FNAME)
   V is a NV-by-3 numeric array containing vertex coordinates,
   F is a NF-by-3 or NF-by-4 array containg vertex indices of each face.

   MESH = readMesh_ply(FNAME)
   Returns mesh vertex and face information into a single structure with
   fields 'vertices' and 'faces'.

   Example
     [v, f] = readMesh_ply('bunny_F1k.ply');
     trisurf(f, v(:,1),v(:,2),v(:,3));
     colormap(gray); axis equal;

   References
   Adapted from Gabriel Peyré's &quot;read_ply&quot; function, that is was a wrapper
   for the &quot;plyread&quot; function written by Pascal Getreuer.

   See also
       meshes3d, <a href="readMesh.html" class="code" title="function varargout = readMesh(filePath, varargin)">readMesh</a>, <a href="readMesh_off.html" class="code" title="function varargout = readMesh_off(fileName)">readMesh_off</a>, <a href="readMesh_stl.html" class="code" title="function varargout = readMesh_stl(fName)">readMesh_stl</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="readMesh.html" class="code" title="function varargout = readMesh(filePath, varargin)">readMesh</a>	READMESH Read a 3D mesh by inferring the format from the file extension.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = readMesh_ply(fileName)</a>
0002 <span class="comment">%READMESH_PLY Read mesh data stored in PLY (Stanford triangle) format.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   [V, F] = readMesh_ply(FNAME)</span>
0005 <span class="comment">%   V is a NV-by-3 numeric array containing vertex coordinates,</span>
0006 <span class="comment">%   F is a NF-by-3 or NF-by-4 array containg vertex indices of each face.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   MESH = readMesh_ply(FNAME)</span>
0009 <span class="comment">%   Returns mesh vertex and face information into a single structure with</span>
0010 <span class="comment">%   fields 'vertices' and 'faces'.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   Example</span>
0013 <span class="comment">%     [v, f] = readMesh_ply('bunny_F1k.ply');</span>
0014 <span class="comment">%     trisurf(f, v(:,1),v(:,2),v(:,3));</span>
0015 <span class="comment">%     colormap(gray); axis equal;</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%   References</span>
0018 <span class="comment">%   Adapted from Gabriel Peyré's &quot;read_ply&quot; function, that is was a wrapper</span>
0019 <span class="comment">%   for the &quot;plyread&quot; function written by Pascal Getreuer.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%   See also</span>
0022 <span class="comment">%       meshes3d, readMesh, readMesh_off, readMesh_stl</span>
0023 
0024 <span class="comment">% ------</span>
0025 <span class="comment">% Author: David Legland</span>
0026 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0027 <span class="comment">% Created: 2018-04-26, using Matlab 9.4.0.813654 (R2018a)</span>
0028 <span class="comment">% Copyright 2018-2024 INRA - Cepia Software Platform</span>
0029 
0030 <span class="comment">%% Open file</span>
0031 
0032 <span class="comment">% check existence of file</span>
0033 <span class="keyword">if</span> ~exist(fileName, <span class="string">'file'</span>)
0034     error(<span class="string">'matGeom:readMesh_ply:FileNotFound'</span>, <span class="keyword">...</span>
0035         [<span class="string">'Could not find file: '</span> fileName]);
0036 <span class="keyword">end</span>
0037 
0038 <span class="comment">% open file in read text mode</span>
0039 [fid, msg] = fopen(fileName, <span class="string">'rt'</span>); 
0040 
0041 <span class="comment">% check file was properly open</span>
0042 <span class="keyword">if</span> fid == -1
0043     error(msg); 
0044 <span class="keyword">end</span>
0045 
0046 <span class="comment">% check file format marker</span>
0047 buf = fscanf(fid, <span class="string">'%s'</span>, 1);
0048 <span class="keyword">if</span> ~strcmp(buf, <span class="string">'ply'</span>)
0049     fclose(fid);
0050     error(<span class="string">'Not a PLY file.'</span>);
0051 <span class="keyword">end</span>
0052 
0053 
0054 <span class="comment">%% Read header</span>
0055 
0056 <span class="comment">% initialize empty fields</span>
0057 ftell(fid);
0058 dataFormat = <span class="string">''</span>;
0059 nComments = 0;
0060 comments = {};      <span class="comment">% for storing any file comments</span>
0061 nElements = 0;
0062 elements = [];      <span class="comment">% structure for holding the element data</span>
0063 elementCounts = []; <span class="comment">% number of each type of element in file</span>
0064 elementNames = {};  <span class="comment">% list of element names in the order they are stored in the file</span>
0065 nProperties = 0;
0066 propertyNames = [];    <span class="comment">% structure of lists of property names</span>
0067 propertyTypes = []; <span class="comment">% corresponding structure recording property types</span>
0068 
0069 <span class="comment">% iterate over the lines of the file until we find the &quot;end_header&quot; line</span>
0070 <span class="keyword">while</span> true
0071     buf = fgetl(fid); <span class="comment">% read one line from file</span>
0072     tokens = split(buf); <span class="comment">% split line into tokens</span>
0073     nToks = length(tokens); <span class="comment">% count tokens</span>
0074     
0075     <span class="keyword">if</span> nToks == 0
0076         <span class="keyword">continue</span>;
0077     <span class="keyword">end</span>
0078 
0079     <span class="comment">% At the beginning of an element, the first token indicates the nature</span>
0080     <span class="comment">% of the element</span>
0081     <span class="keyword">switch</span> lower(tokens{1})
0082         <span class="keyword">case</span> <span class="string">'format'</span>
0083             <span class="comment">% read data format (ascii or binary)</span>
0084             <span class="keyword">if</span> nToks &gt;= 2
0085                 dataFormat = lower(tokens{2});
0086                 <span class="keyword">if</span> nToks == 3 &amp;&amp; ~strcmp(tokens{3},<span class="string">'1.0'</span>)
0087                     fclose(fid);
0088                     error(<span class="string">'Only PLY format version 1.0 supported.'</span>);
0089                 <span class="keyword">end</span>
0090             <span class="keyword">end</span>
0091 
0092         <span class="keyword">case</span> <span class="string">'comment'</span>
0093             <span class="comment">% read file comments</span>
0094             nComments = nComments + 1;
0095             comments{nComments} = <span class="string">''</span>; <span class="comment">%#ok&lt;AGROW&gt;</span>
0096             <span class="keyword">for</span> i = 2:nToks
0097                 comments{nComments} = [comments{nComments}, tokens{i}, <span class="string">' '</span>];
0098             <span class="keyword">end</span>
0099 
0100         <span class="keyword">case</span> <span class="string">'element'</span>
0101             <span class="comment">% element name</span>
0102             <span class="keyword">if</span> nToks &gt;= 3
0103                 <span class="comment">% check element was not already initialized</span>
0104                 <span class="keyword">if</span> isfield(elements,tokens{2})
0105                     fclose(fid);
0106                     error([<span class="string">'Duplicate element name, '''</span>,tokens{2},<span class="string">'''.'</span>]);
0107                 <span class="keyword">end</span>
0108 
0109                 nElements = nElements + 1;
0110                 nProperties = 0;
0111                 elements.(tokens{2}) = [];
0112                 propertyTypes.(tokens{2}) =[];
0113                 elementNames{nElements} = tokens{2}; <span class="comment">%#ok&lt;AGROW&gt;</span>
0114                 propertyNames.(tokens{2}) = {};
0115                 element = tokens{2};
0116                 elementCounts(nElements) = str2double(tokens{3}); <span class="comment">%#ok&lt;AGROW&gt;</span>
0117 
0118                 <span class="keyword">if</span> isnan(elementCounts(nElements))
0119                     fclose(fid);
0120                     error([<span class="string">'Bad element definition: '</span>, buf]);
0121                 <span class="keyword">end</span>
0122             <span class="keyword">else</span>
0123                 error([<span class="string">'Bad element definition: '</span>, buf]);
0124             <span class="keyword">end</span>
0125 
0126         <span class="keyword">case</span> <span class="string">'property'</span>
0127             <span class="comment">% element property</span>
0128             <span class="keyword">if</span> ~isempty(element) &amp;&amp; nToks &gt;= 3
0129                 nProperties = nProperties + 1;
0130 
0131                 <span class="keyword">if</span> isfield(elements.(element), tokens{nToks})
0132                     fclose(fid);
0133                     error([<span class="string">'Duplicate property name, '''</span>,element,<span class="string">'.'</span>,tokens{2},<span class="string">'''.'</span>]);
0134                 <span class="keyword">end</span>
0135 
0136                 <span class="comment">% add property subfield to elements</span>
0137                 elements.(element).(tokens{nToks}) = [];
0138                 <span class="comment">% add property subfield to PropertyTypes and save type</span>
0139                 propertyTypes.(element).(tokens{nToks}) = tokens(2:nToks-1);
0140                 <span class="comment">% record property name order</span>
0141                 propertyNames.(element){nProperties} = tokens{nToks};
0142             <span class="keyword">else</span>
0143                 fclose(fid);
0144                 <span class="keyword">if</span> isempty(element)
0145                     error([<span class="string">'Property definition without element definition: '</span>, buf]);
0146                 <span class="keyword">else</span>
0147                     error([<span class="string">'Bad property definition: '</span>, buf]);
0148                 <span class="keyword">end</span>
0149             <span class="keyword">end</span>
0150 
0151         <span class="keyword">case</span> <span class="string">'end_header'</span> 
0152             <span class="comment">% end of header, break infinite loop</span>
0153             <span class="keyword">break</span>;
0154     <span class="keyword">end</span>
0155 <span class="keyword">end</span>
0156 
0157 
0158 <span class="comment">%% Set reading for specified data format</span>
0159 <span class="keyword">if</span> isempty(dataFormat)
0160     warning(<span class="string">'Data format unspecified, assuming ASCII.'</span>);
0161     dataFormat = <span class="string">'ascii'</span>;
0162 <span class="keyword">end</span>
0163 
0164 <span class="keyword">switch</span> dataFormat
0165     <span class="keyword">case</span> <span class="string">'ascii'</span>
0166         dataFormat = 0;
0167     <span class="keyword">case</span> <span class="string">'binary_little_endian'</span>
0168         dataFormat = 1;
0169     <span class="keyword">case</span> <span class="string">'binary_big_endian'</span>
0170         dataFormat = 2;
0171     <span class="keyword">otherwise</span>
0172         fclose(fid);
0173         error(<span class="string">'Data format ''%s'' not supported.'</span>, dataFormat);
0174 <span class="keyword">end</span>
0175 
0176 <span class="keyword">if</span> dataFormat == 0
0177     <span class="comment">% read the rest of the file as ASCII data</span>
0178     buf = fscanf(fid,<span class="string">'%f'</span>);
0179     offset = 1;
0180 <span class="keyword">else</span>
0181     <span class="comment">% reopen the file in read binary mode</span>
0182     fclose(fid);
0183     
0184     <span class="keyword">if</span> dataFormat == 1
0185         fid = fopen(fileName, <span class="string">'r'</span>, <span class="string">'ieee-le.l64'</span>); <span class="comment">% little endian</span>
0186     <span class="keyword">else</span>
0187         fid = fopen(fileName, <span class="string">'r'</span>, <span class="string">'ieee-be.l64'</span>); <span class="comment">% big endian</span>
0188     <span class="keyword">end</span>
0189     
0190     <span class="comment">% find the end of the header again (using ftell on the old handle doesn't give the correct position)</span>
0191     bufferSize = 8192;
0192     buf = [blanks(10),char(fread(fid,bufferSize,<span class="string">'uchar'</span>)')];
0193     i = [];
0194     tmp = -11;
0195     
0196     <span class="keyword">while</span> isempty(i)
0197         <span class="comment">% look for end_header + CR/LF</span>
0198         i = strfind(buf, [<span class="string">'end_header'</span>, 13, 10]);
0199         <span class="comment">% look for end_header + LF</span>
0200         i = [i, strfind(buf, [<span class="string">'end_header'</span>, 10])]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0201         
0202         <span class="keyword">if</span> isempty(i)
0203             tmp = tmp + bufferSize;
0204             buf = [buf(bufferSize+1:bufferSize+10), char(fread(fid,bufferSize,<span class="string">'uchar'</span>)')];
0205         <span class="keyword">end</span>
0206     <span class="keyword">end</span>
0207     
0208     <span class="comment">% seek to just after the line feed</span>
0209     fseek(fid, i + tmp + 11 + (buf(i + 10) == 13), -1);
0210 <span class="keyword">end</span>
0211 
0212 
0213 <span class="comment">%% Read element data</span>
0214 
0215 <span class="comment">% PLY and MATLAB data types (for fread)</span>
0216 plyTypeNames = {<span class="string">'char'</span>,<span class="string">'uchar'</span>,<span class="string">'short'</span>,<span class="string">'ushort'</span>,<span class="string">'int'</span>,<span class="string">'uint'</span>,<span class="string">'float'</span>,<span class="string">'double'</span>, <span class="keyword">...</span>
0217     <span class="string">'char8'</span>,<span class="string">'uchar8'</span>,<span class="string">'short16'</span>,<span class="string">'ushort16'</span>,<span class="string">'int32'</span>,<span class="string">'uint32'</span>,<span class="string">'float32'</span>,<span class="string">'double64'</span>};
0218 matlabTypeNames = {<span class="string">'schar'</span>,<span class="string">'uchar'</span>,<span class="string">'int16'</span>,<span class="string">'uint16'</span>,<span class="string">'int32'</span>,<span class="string">'uint32'</span>,<span class="string">'single'</span>,<span class="string">'double'</span>};
0219 dataTypeSizes = [1,1,2,2,4,4,4,8];    <span class="comment">% size in bytes of each type</span>
0220 
0221 <span class="comment">% iterate over element types</span>
0222 <span class="keyword">for</span> i = 1:nElements
0223     <span class="comment">% get current element property information</span>
0224     currPropNames = propertyNames.(elementNames{i});
0225     currPropTypes = propertyTypes.(elementNames{i});
0226     nProperties = size(currPropNames,2);
0227     
0228     <span class="comment">% fprintf('Reading %s...\n',ElementNames{i});</span>
0229     
0230     <span class="keyword">if</span> dataFormat == 0
0231         <span class="comment">% read ASCII data</span>
0232         type = zeros(1, nProperties);
0233         <span class="keyword">for</span> j = 1:nProperties
0234             tokens = currPropTypes.(currPropNames{j});
0235             
0236             <span class="keyword">if</span> strcmpi(tokens{1},<span class="string">'list'</span>)
0237                 type(j) = 1;
0238             <span class="keyword">end</span>
0239         <span class="keyword">end</span>
0240         
0241         <span class="comment">% parse buffer</span>
0242         <span class="keyword">if</span> ~any(type)
0243             <span class="comment">% no list types</span>
0244             rawData = reshape(buf(offset:offset+elementCounts(i)*nProperties-1),nProperties,elementCounts(i))';
0245             offset = offset + elementCounts(i)*nProperties;
0246         <span class="keyword">else</span>
0247             allData = cell(nProperties,1);
0248             
0249             <span class="keyword">for</span> k = 1:nProperties
0250                 allData{k} = cell(elementCounts(i),1);
0251             <span class="keyword">end</span>
0252             
0253             <span class="comment">% list type</span>
0254             <span class="keyword">for</span> j = 1:elementCounts(i)
0255                 <span class="keyword">for</span> k = 1:nProperties
0256                     <span class="keyword">if</span> ~type(k)
0257                         rawData(j,k) = buf(offset);
0258                         offset = offset + 1;
0259                     <span class="keyword">else</span>
0260                         tmp = buf(offset);
0261                         allData{k}{j} = buf(offset+(1:tmp))';
0262                         offset = offset + tmp + 1;
0263                     <span class="keyword">end</span>
0264                 <span class="keyword">end</span>
0265             <span class="keyword">end</span>
0266         <span class="keyword">end</span>
0267     <span class="keyword">else</span>
0268         <span class="comment">% read binary data</span>
0269         <span class="comment">% translate PLY data type names to MATLAB data type names</span>
0270         listFlag = 0; <span class="comment">% = 1 if there is a list type</span>
0271         sameFlag = 1; <span class="comment">% = 1 if all types are the same</span>
0272         
0273         type = cell(1,nProperties);
0274         type2 = type;
0275         typeSize = zeros(1,nProperties);
0276         typeSize2 = typeSize;
0277         <span class="keyword">for</span> j = 1:nProperties
0278             tokens = currPropTypes.(currPropNames{j});
0279             
0280             <span class="keyword">if</span> ~strcmp(tokens{1}, <span class="string">'list'</span>)    <span class="comment">% non-list type</span>
0281                 tmp = rem(find(matches(plyTypeNames,tokens{1}))-1,8)+1;
0282                 
0283                 <span class="keyword">if</span> ~isempty(tmp)
0284                     typeSize(j) = dataTypeSizes(tmp);
0285                     type{j} = matlabTypeNames{tmp};
0286                     typeSize2(j) = 0;
0287                     type2{j} = <span class="string">''</span>;
0288                     
0289                     sameFlag = sameFlag &amp; strcmp(type{1},type{j});
0290                 <span class="keyword">else</span>
0291                     fclose(fid);
0292                     error([<span class="string">'Unknown property data type, '''</span>,tokens{1},<span class="string">''', in '</span>, <span class="keyword">...</span>
0293                         elementNames{i},<span class="string">'.'</span>,currPropNames{j},<span class="string">'.'</span>]);
0294                 <span class="keyword">end</span>
0295             <span class="keyword">else</span> <span class="comment">% list type</span>
0296                 <span class="keyword">if</span> length(tokens) == 3
0297                     listFlag = 1;
0298                     sameFlag = 0;
0299                     tmp = rem(find(matches(plyTypeNames,tokens{2}))-1,8)+1;
0300                     tmp2 = rem(find(matches(plyTypeNames,tokens{3}))-1,8)+1;
0301                     
0302                     <span class="keyword">if</span> ~isempty(tmp) &amp;&amp; ~isempty(tmp2)
0303                         typeSize(j) = dataTypeSizes(tmp);
0304                         type{j} = matlabTypeNames{tmp};
0305                         typeSize2(j) = dataTypeSizes(tmp2);
0306                         type2{j} = matlabTypeNames{tmp2};
0307                     <span class="keyword">else</span>
0308                         fclose(fid);
0309                         error([<span class="string">'Unknown property data type, ''list '</span>,tokens{2},<span class="string">' '</span>,tokens{3},<span class="string">''', in '</span>, <span class="keyword">...</span>
0310                             elementNames{i},<span class="string">'.'</span>,currPropNames{j},<span class="string">'.'</span>]);
0311                     <span class="keyword">end</span>
0312                 <span class="keyword">else</span>
0313                     fclose(fid);
0314                     error([<span class="string">'Invalid list syntax in '</span>,elementNames{i},<span class="string">'.'</span>,currPropNames{j},<span class="string">'.'</span>]);
0315                 <span class="keyword">end</span>
0316             <span class="keyword">end</span>
0317         <span class="keyword">end</span>
0318         
0319         <span class="comment">% read file</span>
0320         <span class="keyword">if</span> ~listFlag
0321             <span class="keyword">if</span> sameFlag
0322                 <span class="comment">% no list types, all the same type (fast)</span>
0323                 rawData = fread(fid,[nProperties,elementCounts(i)],type{1})';
0324             <span class="keyword">else</span>
0325                 <span class="comment">% no list types, mixed type</span>
0326                 rawData = zeros(elementCounts(i),nProperties);
0327                 
0328                 <span class="keyword">for</span> j = 1:elementCounts(i)
0329                     <span class="keyword">for</span> k = 1:nProperties
0330                         rawData(j,k) = fread(fid,1,type{k});
0331                     <span class="keyword">end</span>
0332                 <span class="keyword">end</span>
0333             <span class="keyword">end</span>
0334         <span class="keyword">else</span>
0335             allData = cell(nProperties,1);
0336             
0337             <span class="keyword">for</span> k = 1:nProperties
0338                 allData{k} = cell(elementCounts(i),1);
0339             <span class="keyword">end</span>
0340             
0341             <span class="keyword">if</span> nProperties == 1
0342                 bufferSize = 512;
0343                 nSkip = 4;
0344                 j = 0;
0345                 
0346                 <span class="comment">% list type, one property (fast if lists are usually the same length)</span>
0347                 <span class="keyword">while</span> j &lt; elementCounts(i)
0348                     Position = ftell(fid);
0349                     <span class="comment">% read in BufSize count values, assuming all counts = nSkip</span>
0350                     [buf,bufferSize] = fread(fid,bufferSize,type{1},nSkip*typeSize2(1));
0351                     miss = find(buf ~= nSkip); <span class="comment">% find first count that is not nSkip</span>
0352                     fseek(fid,Position + typeSize(1),-1); <span class="comment">% seek back to after first count</span>
0353                     
0354                     <span class="keyword">if</span> isempty(miss) <span class="comment">% all counts are nSkip</span>
0355                         buf = fread(fid,[nSkip,bufferSize],[int2str(nSkip),<span class="string">'*'</span>,type2{1}],typeSize(1))';
0356                         fseek(fid,-typeSize(1),0); <span class="comment">% undo last skip</span>
0357                         
0358                         <span class="keyword">for</span> k = 1:bufferSize
0359                             allData{1}{j+k} = buf(k,:);
0360                         <span class="keyword">end</span>
0361                         
0362                         j = j + bufferSize;
0363                         bufferSize = floor(1.5*bufferSize);
0364                     <span class="keyword">else</span>
0365                         <span class="keyword">if</span> miss(1) &gt; 1 <span class="comment">% some counts are numSkip</span>
0366                             Buf2 = fread(fid,[nSkip,miss(1)-1],[int2str(nSkip),<span class="string">'*'</span>,type2{1}],typeSize(1));
0367                             Buf2 = Buf2';
0368                             
0369                             <span class="keyword">for</span> k = 1:miss(1)-1
0370                                 allData{1}{j+k} = Buf2(k,:);
0371                             <span class="keyword">end</span>
0372                             
0373                             j = j + k;
0374                         <span class="keyword">end</span>
0375 
0376                         <span class="comment">% Alec: check if done and rewind one step</span>
0377                         <span class="keyword">if</span> j &gt;= elementCounts(i)
0378                             fseek(fid,-1,0);
0379                             <span class="keyword">break</span>;
0380                         <span class="keyword">end</span>
0381                         
0382                         <span class="comment">% read in the list with the missed count</span>
0383                         nSkip = buf(miss(1));
0384                         j = j + 1;
0385                         allData{1}{j} = fread(fid,[1,nSkip],type2{1});
0386                         bufferSize = ceil(0.6*bufferSize);
0387                     <span class="keyword">end</span>
0388                 <span class="keyword">end</span>
0389             <span class="keyword">else</span>
0390                 <span class="comment">% list type(s), multiple properties (slow)</span>
0391                 rawData = zeros(elementCounts(i),nProperties);
0392                 
0393                 <span class="keyword">for</span> j = 1:elementCounts(i)
0394                     <span class="keyword">for</span> k = 1:nProperties
0395                         <span class="keyword">if</span> isempty(type2{k})
0396                             rawData(j,k) = fread(fid,1,type{k});
0397                         <span class="keyword">else</span>
0398                             tmp = fread(fid,1,type{k});
0399                             allData{k}{j} = fread(fid,[1,tmp],type2{k});
0400                         <span class="keyword">end</span>
0401                     <span class="keyword">end</span>
0402                 <span class="keyword">end</span>
0403             <span class="keyword">end</span>
0404         <span class="keyword">end</span>
0405     <span class="keyword">end</span>
0406     
0407     <span class="comment">% put data into 'elements' structure</span>
0408     <span class="keyword">for</span> k = 1:nProperties
0409         <span class="keyword">if</span> (~dataFormat &amp;&amp; ~type(k)) || (dataFormat &amp;&amp; isempty(type2{k}))
0410             elements.(elementNames{i}).(currPropNames{k}) = rawData(:,k);
0411         <span class="keyword">else</span>
0412             elements.(elementNames{i}).(currPropNames{k}) = allData{k};
0413         <span class="keyword">end</span>
0414     <span class="keyword">end</span>
0415 <span class="keyword">end</span>
0416 
0417 clear rawData allData;
0418 fclose(fid);
0419 
0420 
0421 <span class="comment">%% Post-processing</span>
0422 
0423 <span class="comment">% find the index of the element corresponding to face vertex indices</span>
0424 possibleFacePropertyNames = <span class="keyword">...</span>
0425     {<span class="string">'vertex_indices'</span>, <span class="string">'vertex_indexes'</span>, <span class="string">'vertex_index'</span>, <span class="string">'indices'</span>, <span class="string">'indexes'</span>};
0426 facePropertyNameIdx = find(matches(possibleFacePropertyNames, fieldnames(elements.face)));
0427 assert(isscalar(facePropertyNameIdx))
0428 
0429 <span class="comment">% retrieve face vertex data</span>
0430 faces = elements.face.(possibleFacePropertyNames{facePropertyNameIdx});
0431 
0432 <span class="comment">% convert face array from 0-indexing into 1-indexing,</span>
0433 <span class="comment">% and attempt to convert cell array into numeric array,</span>
0434 lengths = cellfun(@length, faces);
0435 maxLength = max(lengths);
0436 <span class="keyword">if</span> all(maxLength == lengths)
0437     faces = cell2mat(faces)+1;
0438 <span class="keyword">else</span>
0439     faces = cellfun(@(x) x+1, faces, <span class="string">'uni'</span>, 0);
0440 <span class="keyword">end</span>
0441 
0442 <span class="comment">% retrieve vertex data</span>
0443 vertices = [elements.vertex.x, elements.vertex.y, elements.vertex.z];
0444 
0445 <span class="comment">% format output arguments</span>
0446 varargout = formatMeshOutput(nargout, vertices, faces);
0447 <span class="keyword">if</span> nargout == 1
0448     varargout{1}.comment = comments;
0449 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>