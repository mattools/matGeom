<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of meshCurvatures</title>
  <meta name="keywords" content="meshCurvatures">
  <meta name="description" content="MESHCURVATURES Compute principal curvatures on mesh vertices.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">meshes3d</a> &gt; meshCurvatures.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\meshes3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>meshCurvatures
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MESHCURVATURES Compute principal curvatures on mesh vertices.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [C1, C2, U1, U2, H, K, N] = meshCurvatures(vertices, faces, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MESHCURVATURES Compute principal curvatures on mesh vertices.

   [C1, C2] = meshCurvatures(VERTICES, FACES)
   Computes the principal curvatures C1 and C2 for each vertex of the mesh
   defined by VERTICES and FACES.

   [C1, C2] = meshCurvatures(..., PNAME, PVALUE)
   Provides additional input arguments based on a list of name-value pairs
   of arguments. Parameter names can be:
   * 'SmoothingSteps'      (integer, default: 3) 
       Specifies the number of steps for smoothing vertex curvature
       tensors.  
   * 'Verbose'             (boolean, default: true) 
       Displays details about algorithm processing. 
   * 'ShowProgress'        (boolean, default: true) 
       Displays a text-based progress bar.

   Algorithm
   The function is adapted from the &quot;compute_curvature&quot; function, in the
   &quot;toolbox_graph&quot; from Gabriel Peyre.
   The basic idea is to define a curvature tensor for each edge, by
   assigning a minimum curvature equal to zero along the edge, and a
   maximum curvature equal to the dihedral angle across the edge.
   Averaging around the neighbors of a vertex v yields a summation formula
   over the neighbor edges to compute the curvature tensor of a vertex:
           1
   C(v) = ----     Sum       \beta(e) || e \cap A(v) || ebar ebar^t
          A(v)  {e \in A(v)}
   where:
   * A(v) is the neighborhood region, usually defined as a 'ring' around
       the vertex v
   * beta(e) is the dihedral angle between the normals of the two faces
       incident to edge e
   * || e \cap A(v) || is the length of e (more exactly, the length of the
       part of e contained within the neighborhood region
   * ebar is the normalized edge

   The curvature tensor is then decomposed into C = P D P^-1, with P
   containing main direction vectors and normal, and D being a diagonal
   matrix with the two main curvatures and zero along the diagonal.
   
   References
   * David Cohen-Steiner and Jean-Marie Morvan (2003). 
       &quot;Restricted Delaunay triangulations and normal cycle&quot;. 
       In Proc. 19th Annual ACM Symposium on Computational Geometry, 
       pages 237-246. 
   * Pierre Alliez, David Cohen-Steiner, Olivier Devillers, Bruno Levy,
       and Mathieu Desbrun (2003). &quot;Anisotropic Polygonal Remeshing&quot;. 
       ACM Transactions on Graphics. 
       (SIGGRAPH '2003 Conference Proceedings)
   * Mario Botsch, Leif Kobbelt, M. Pauly, P. Alliez, B. Levy (2010).
       &quot;Polygon Mesh Processing&quot;, Taylor and Francis Group, New York.
   
   Example
     [v, f] = torusMesh;
     f2 = triangulateFaces(f);
     [c1, c2] = meshCurvatures(v, f2);
     figure; hold on; axis equal; view(3);
     drawMesh(v, f2, 'VertexColor', c1 .* c2);

   See also
     meshes3d, <a href="drawMesh.html" class="code" title="function varargout = drawMesh(varargin)">drawMesh</a>, <a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../matGeom/geom3d/crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>	CROSSPRODUCT3D Vector cross product faster than inbuilt MATLAB cross.</li><li><a href="meshFaceNormals.html" class="code" title="function normals = meshFaceNormals(varargin)">meshFaceNormals</a>	MESHFACENORMALS Compute normal vector of faces in a 3D mesh.</li><li><a href="meshVolume.html" class="code" title="function vol = meshVolume(varargin)">meshVolume</a>	MESHVOLUME (Signed) volume of the space enclosed by a polygonal mesh.</li><li><a href="smoothMeshFunction.html" class="code" title="function f = smoothMeshFunction(vertices, faces, f, varargin) %#ok<INUSL>">smoothMeshFunction</a>	SMOOTHMESHFUNCTION Apply smoothing on a functions defines on mesh vertices.</li><li><a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a>	TRIANGULATEFACES Convert face array to an array of triangular faces.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [C1, C2, U1, U2, H, K, N] = meshCurvatures(vertices, faces, varargin)</a>
0002 <span class="comment">%MESHCURVATURES Compute principal curvatures on mesh vertices.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   [C1, C2] = meshCurvatures(VERTICES, FACES)</span>
0005 <span class="comment">%   Computes the principal curvatures C1 and C2 for each vertex of the mesh</span>
0006 <span class="comment">%   defined by VERTICES and FACES.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   [C1, C2] = meshCurvatures(..., PNAME, PVALUE)</span>
0009 <span class="comment">%   Provides additional input arguments based on a list of name-value pairs</span>
0010 <span class="comment">%   of arguments. Parameter names can be:</span>
0011 <span class="comment">%   * 'SmoothingSteps'      (integer, default: 3)</span>
0012 <span class="comment">%       Specifies the number of steps for smoothing vertex curvature</span>
0013 <span class="comment">%       tensors.</span>
0014 <span class="comment">%   * 'Verbose'             (boolean, default: true)</span>
0015 <span class="comment">%       Displays details about algorithm processing.</span>
0016 <span class="comment">%   * 'ShowProgress'        (boolean, default: true)</span>
0017 <span class="comment">%       Displays a text-based progress bar.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   Algorithm</span>
0020 <span class="comment">%   The function is adapted from the &quot;compute_curvature&quot; function, in the</span>
0021 <span class="comment">%   &quot;toolbox_graph&quot; from Gabriel Peyre.</span>
0022 <span class="comment">%   The basic idea is to define a curvature tensor for each edge, by</span>
0023 <span class="comment">%   assigning a minimum curvature equal to zero along the edge, and a</span>
0024 <span class="comment">%   maximum curvature equal to the dihedral angle across the edge.</span>
0025 <span class="comment">%   Averaging around the neighbors of a vertex v yields a summation formula</span>
0026 <span class="comment">%   over the neighbor edges to compute the curvature tensor of a vertex:</span>
0027 <span class="comment">%           1</span>
0028 <span class="comment">%   C(v) = ----     Sum       \beta(e) || e \cap A(v) || ebar ebar^t</span>
0029 <span class="comment">%          A(v)  {e \in A(v)}</span>
0030 <span class="comment">%   where:</span>
0031 <span class="comment">%   * A(v) is the neighborhood region, usually defined as a 'ring' around</span>
0032 <span class="comment">%       the vertex v</span>
0033 <span class="comment">%   * beta(e) is the dihedral angle between the normals of the two faces</span>
0034 <span class="comment">%       incident to edge e</span>
0035 <span class="comment">%   * || e \cap A(v) || is the length of e (more exactly, the length of the</span>
0036 <span class="comment">%       part of e contained within the neighborhood region</span>
0037 <span class="comment">%   * ebar is the normalized edge</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%   The curvature tensor is then decomposed into C = P D P^-1, with P</span>
0040 <span class="comment">%   containing main direction vectors and normal, and D being a diagonal</span>
0041 <span class="comment">%   matrix with the two main curvatures and zero along the diagonal.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   References</span>
0044 <span class="comment">%   * David Cohen-Steiner and Jean-Marie Morvan (2003).</span>
0045 <span class="comment">%       &quot;Restricted Delaunay triangulations and normal cycle&quot;.</span>
0046 <span class="comment">%       In Proc. 19th Annual ACM Symposium on Computational Geometry,</span>
0047 <span class="comment">%       pages 237-246.</span>
0048 <span class="comment">%   * Pierre Alliez, David Cohen-Steiner, Olivier Devillers, Bruno Levy,</span>
0049 <span class="comment">%       and Mathieu Desbrun (2003). &quot;Anisotropic Polygonal Remeshing&quot;.</span>
0050 <span class="comment">%       ACM Transactions on Graphics.</span>
0051 <span class="comment">%       (SIGGRAPH '2003 Conference Proceedings)</span>
0052 <span class="comment">%   * Mario Botsch, Leif Kobbelt, M. Pauly, P. Alliez, B. Levy (2010).</span>
0053 <span class="comment">%       &quot;Polygon Mesh Processing&quot;, Taylor and Francis Group, New York.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%   Example</span>
0056 <span class="comment">%     [v, f] = torusMesh;</span>
0057 <span class="comment">%     f2 = triangulateFaces(f);</span>
0058 <span class="comment">%     [c1, c2] = meshCurvatures(v, f2);</span>
0059 <span class="comment">%     figure; hold on; axis equal; view(3);</span>
0060 <span class="comment">%     drawMesh(v, f2, 'VertexColor', c1 .* c2);</span>
0061 <span class="comment">%</span>
0062 <span class="comment">%   See also</span>
0063 <span class="comment">%     meshes3d, drawMesh, triangulateFaces</span>
0064 <span class="comment">%</span>
0065 
0066 <span class="comment">% ------</span>
0067 <span class="comment">% Author: David Legland</span>
0068 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0069 <span class="comment">% Created: 2021-09-21, using Matlab 9.10.0.1684407 (R2021a) Update 3</span>
0070 <span class="comment">% Copyright 2021-2024 INRAE - BIA Research Unit - BIBS Platform (Nantes)</span>
0071 
0072 <span class="comment">%% Process input arguments</span>
0073 
0074 <span class="comment">% default values for options</span>
0075 nIters = 3;
0076 verbose = true;
0077 showProgress = true;
0078 
0079 <span class="keyword">while</span> length(varargin) &gt; 1
0080     name = varargin{1};
0081     <span class="keyword">if</span> strcmpi(name, <span class="string">'SmoothingSteps'</span>)
0082         nIters = varargin{2};
0083     <span class="keyword">elseif</span> strcmpi(name, <span class="string">'Verbose'</span>)
0084         verbose = varargin{2};
0085     <span class="keyword">elseif</span> strcmpi(name, <span class="string">'ShowProgress'</span>)
0086         showProgress = varargin{2};
0087     <span class="keyword">else</span>
0088         error(<span class="string">'Unknown option: %s'</span>, name);
0089     <span class="keyword">end</span>
0090     varargin(1:2) = [];
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% validate vertices</span>
0094 <span class="keyword">if</span> ~isnumeric(vertices) || size(vertices, 2) ~= 3
0095     error(<span class="string">'Requires vertices to be a N-by-3 numeric array'</span>);
0096 <span class="keyword">end</span>
0097 
0098 <span class="comment">% ensure faces are triangular</span>
0099 <span class="keyword">if</span> ~isnumeric(faces) || size(faces, 2) &gt; 3
0100     warning(<span class="string">'requires triangle mesh, forces triangulation'</span>);
0101     faces = <a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a>(faces);
0102 <span class="keyword">end</span>
0103 
0104 
0105 <span class="comment">%% Retrieve adjacency relationships</span>
0106 
0107 <span class="keyword">if</span> verbose
0108     disp(<span class="string">'compute adjacencies'</span>);
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">% number of elements of each type</span>
0112 nv = size(vertices, 1);
0113 nf = size(faces, 1);
0114 
0115 <span class="comment">% ev1 and ev2 are indices of source and target vertex of each edge</span>
0116 <span class="comment">% (recomputed later)</span>
0117 ev1 = [faces(:,1); faces(:,2); faces(:,3)];
0118 ev2 = [faces(:,2); faces(:,3); faces(:,1)];
0119 
0120 <span class="comment">% Compute sparse matrix representing edge-to-face adjacency</span>
0121 s = [1:nf 1:nf 1:nf]';
0122 A = sparse(ev1, ev2, s, nv, nv); 
0123 
0124 <span class="comment">% converts sparse matrix to indices of adjacent vertices and faces</span>
0125 [~, ~, ef1] = find(A);         <span class="comment">% index of 'right' face</span>
0126 [ev1, ev2, ef2] = find(A');    <span class="comment">% index of 'left' face, and of vertices</span>
0127 
0128 <span class="comment">% edges are consdered twice (one for each vertex)</span>
0129 <span class="comment">% keep only the edge with lower source index</span>
0130 inds = find(ev1 &lt; ev2);
0131 ef1 = ef1(inds);
0132 ef2 = ef2(inds);
0133 ev1 = ev1(inds); 
0134 ev2 = ev2(inds);
0135 
0136 <span class="comment">% number of edges</span>
0137 ne = length(ev1);
0138 
0139 
0140 <span class="comment">%% Compute geometry features</span>
0141 
0142 <span class="comment">% compute edge direction vectors</span>
0143 edgeVectors = vertices(ev2,:) - vertices(ev1,:);
0144 
0145 <span class="comment">% normalize edge direction vecotrs</span>
0146 d = sqrt(sum(edgeVectors.^2, 2));
0147 edgeVectors = bsxfun(@rdivide, edgeVectors, d);
0148 
0149 <span class="comment">% avoid too large numerics</span>
0150 d = d ./ mean(d);
0151 
0152 <span class="comment">% normals to faces</span>
0153 normals = <a href="meshFaceNormals.html" class="code" title="function normals = meshFaceNormals(varargin)">meshFaceNormals</a>(vertices, faces);
0154 
0155 <span class="comment">% ensure normals point outward the mesh</span>
0156 <span class="keyword">if</span> <a href="meshVolume.html" class="code" title="function vol = meshVolume(varargin)">meshVolume</a>(vertices, faces) &lt; 0
0157     normals = -normals;
0158 <span class="keyword">end</span>
0159 
0160 <span class="comment">% inner product of normals</span>
0161 dp = sum(normals(ef1, :) .* normals(ef2, :), 2);
0162 
0163 <span class="comment">% compute the (unsigned) dihedral angle between the normals of the two</span>
0164 <span class="comment">% faces incident to each edge</span>
0165 beta = acos(min(max(dp, -1), 1));
0166 
0167 <span class="comment">% relatice orientation of face normals cross product and edge orientation</span>
0168 cp = <a href="../../matGeom/geom3d/crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>(normals(ef1, :), normals(ef2, :));
0169 si = sign(sum(cp .* edgeVectors, 2));
0170 
0171 <span class="comment">% compute signed dihedral angle</span>
0172 beta = beta .* si;
0173 
0174 
0175 <span class="comment">%% Compute tensors</span>
0176 
0177 <span class="keyword">if</span> verbose
0178     disp(<span class="string">'compute edge tensors'</span>);
0179 <span class="keyword">end</span>
0180 
0181 <span class="comment">% curvature tensor of each edge</span>
0182 T = zeros(3, 3, ne);
0183 <span class="keyword">for</span> i = 1:3
0184     <span class="keyword">for</span> j = 1:i
0185         T(i, j, :) = reshape(edgeVectors(:,i) .* edgeVectors(:,j), 1, 1, ne);
0186         T(j, i, :) = T(i, j, :);
0187     <span class="keyword">end</span>
0188 <span class="keyword">end</span>
0189 T = bsxfun(@times, T, reshape(d .* beta, [1 1 ne]));
0190 
0191 <span class="comment">% curvature tensor of each vertex by pooling edge tensors</span>
0192 Tv = zeros(3, 3, nv);
0193 w = zeros(1, 1, nv);
0194 <span class="keyword">for</span> k = 1:ne
0195     <span class="keyword">if</span> showProgress
0196         progressbar(k, ne);
0197     <span class="keyword">end</span>
0198     Tv(:,:,ev1(k)) = Tv(:,:,ev1(k)) + T(:,:,k);
0199     Tv(:,:,ev2(k)) = Tv(:,:,ev2(k)) + T(:,:,k);
0200     w(:,:,ev1(k)) = w(:,:,ev1(k)) + 1;
0201     w(:,:,ev2(k)) = w(:,:,ev2(k)) + 1;
0202 <span class="keyword">end</span>
0203 w(w &lt; eps) = 1;
0204 Tv = Tv ./ repmat(w, [3 3 1]);
0205 
0206 <span class="keyword">if</span> verbose
0207     disp(<span class="string">'average vertex tensors'</span>);
0208 <span class="keyword">end</span>
0209 
0210 <span class="comment">% apply smoothing on the tensor field</span>
0211 <span class="keyword">for</span> i = 1:3
0212     <span class="keyword">for</span> j = 1:3
0213         a = Tv(i, j, :);
0214         a = <a href="smoothMeshFunction.html" class="code" title="function f = smoothMeshFunction(vertices, faces, f, varargin) %#ok<INUSL>">smoothMeshFunction</a>(vertices, faces, a(:), nIters);
0215         Tv(i, j, :) = reshape(a, [1 1 nv]);
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 
0219 
0220 <span class="comment">%% Retrieve curvatures and eigen vectors from tensors</span>
0221 
0222 <span class="keyword">if</span> verbose
0223     disp(<span class="string">'retrieve curvatures'</span>);
0224 <span class="keyword">end</span>
0225 
0226 <span class="comment">% allocate memory</span>
0227 U = zeros(3, 3, nv);
0228 D = zeros(3, nv);
0229 
0230 <span class="comment">% iterate over vertices</span>
0231 <span class="keyword">for</span> k = 1:nv
0232     <span class="comment">% display progress</span>
0233     <span class="keyword">if</span> showProgress
0234         progressbar(k,nv);
0235     <span class="keyword">end</span>
0236     
0237     <span class="comment">% extract eigenvectors and eigenvalues for current vertex</span>
0238     [u, d] = eig(Tv(:,:,k));
0239     d = real(diag(d));
0240     
0241     <span class="comment">% sort acording to [normal, min curv, max curv]</span>
0242     [~, I] = sort(abs(d));    
0243     D(:, k) = d(I);
0244     U(:, :, k) = real(u(:,I));
0245 <span class="keyword">end</span>
0246 
0247 <span class="comment">% retrieve main curvatures and associated directions</span>
0248 C1 = D(2,:)';
0249 C2 = D(3,:)';
0250 U1 = squeeze(U(:,3,:))';
0251 U2 = squeeze(U(:,2,:))';
0252 
0253 <span class="comment">% enforce C1 &lt; C2</span>
0254 inds = find(C1 &gt; C2);
0255 C1tmp = C1; 
0256 U1tmp = U1;
0257 C1(inds) = C2(inds); 
0258 C2(inds) = C1tmp(inds);
0259 U1(inds,:) = U2(inds,:); 
0260 U2(inds,:) = U1tmp(inds,:);
0261 
0262 <span class="comment">% compute optional output arguments</span>
0263 <span class="keyword">if</span> nargout &gt; 4
0264     <span class="comment">% average and gaussian curvatures</span>
0265     H = (C1 + C2) / 2;
0266     K = C1 .* C2;
0267     
0268     <span class="keyword">if</span> nargout &gt; 6
0269         <span class="comment">% normal vector for each vertex</span>
0270         N = squeeze(U(:,1,:))';
0271     <span class="keyword">end</span>
0272 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>