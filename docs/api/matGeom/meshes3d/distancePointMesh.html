<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of distancePointMesh</title>
  <meta name="keywords" content="distancePointMesh">
  <meta name="description" content="DISTANCEPOINTMESH Shortest distance between a (3D) point and a triangle mesh.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">meshes3d</a> &gt; distancePointMesh.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\meshes3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>distancePointMesh
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>DISTANCEPOINTMESH Shortest distance between a (3D) point and a triangle mesh.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [dist, proj] = distancePointMesh(points, vertices, faces, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">DISTANCEPOINTMESH Shortest distance between a (3D) point and a triangle mesh.

   DIST = distancePointMesh(POINTS, VERTICES, FACES)
   Returns the shortest distance between the query point(s) POINTS and the
   triangular mesh defined by the set of vertex coordinates VERTICES and
   the set of faces FACES. POINTS is a NP-by-3 array, VERTICES is a 
   NV-by-3 array, and FACES is a NF-by-3 array of vertex indices.
   If FACES is NF-by-4 array, it is converted to a (NF*2)-by-3 array.
   DIST is the NP-by-1 vector of distances.

   [DIST, PROJ] = distancePointMesh(...)
   Also returns the NP-by-3 projection of the query point(s) on the 
   triangular mesh.

   ... = distancePointMesh(..., 'algorithm', ALGO)
   Allows to choose the type of algorithm. Options are:
   * sequential:   process each face sequentially, using the function
               distancePointTriangle3d 
   * vectorized:   vectorized algorithm, usually faster for large number
               of faces
   * auto:         (default) automatically choose the most appropriate
               between sequential and vectorized.

   Example
     [V, F] = torusMesh();
     F2 = triangulateFaces(F);
     P = [10 20 30];
     [D, PROJ] = distancePointMesh(P, V, F2);
     figure; drawMesh(V, F)
     view(3); axis equal; lighting gouraud; light;
     drawPoint3d(P);
     drawPoint3d(PROJ, 'm*');
     drawEdge3d([P PROJ], 'linewidth', 2, 'color', 'b');

   See also
     distancePointTriangle3d

   References
   * &quot;Distance Between Point and Triangle in 3D&quot;, David Eberly
       https://www.geometrictools.com/Documentation/DistancePoint3Triangle3.pdf
   * &quot;Distance between a point and a triangle in 3d&quot;, by Gwendolyn Fischer
       https://mathworks.com/matlabcentral/fileexchange/22857
   * &quot;Distance Between Point and Triangulated Surface&quot;, by Daniel Frisch
       https://www.mathworks.com/matlabcentral/fileexchange/52882</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../matGeom/geom3d/distancePointTriangle3d.html" class="code" title="function [dist, proj] = distancePointTriangle3d(point, triangle)">distancePointTriangle3d</a>	DISTANCEPOINTTRIANGLE3D Minimum distance between a 3D point and a 3D triangle.</li><li><a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a>	TRIANGULATEFACES Convert face array to an array of triangular faces.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [dist, proj] = distancePointTrimesh_vectorized(point, vertices, faces)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [dist, proj] = distancePointMesh(points, vertices, faces, varargin)</a>
0002 <span class="comment">%DISTANCEPOINTMESH Shortest distance between a (3D) point and a triangle mesh.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   DIST = distancePointMesh(POINTS, VERTICES, FACES)</span>
0005 <span class="comment">%   Returns the shortest distance between the query point(s) POINTS and the</span>
0006 <span class="comment">%   triangular mesh defined by the set of vertex coordinates VERTICES and</span>
0007 <span class="comment">%   the set of faces FACES. POINTS is a NP-by-3 array, VERTICES is a</span>
0008 <span class="comment">%   NV-by-3 array, and FACES is a NF-by-3 array of vertex indices.</span>
0009 <span class="comment">%   If FACES is NF-by-4 array, it is converted to a (NF*2)-by-3 array.</span>
0010 <span class="comment">%   DIST is the NP-by-1 vector of distances.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   [DIST, PROJ] = distancePointMesh(...)</span>
0013 <span class="comment">%   Also returns the NP-by-3 projection of the query point(s) on the</span>
0014 <span class="comment">%   triangular mesh.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   ... = distancePointMesh(..., 'algorithm', ALGO)</span>
0017 <span class="comment">%   Allows to choose the type of algorithm. Options are:</span>
0018 <span class="comment">%   * sequential:   process each face sequentially, using the function</span>
0019 <span class="comment">%               distancePointTriangle3d</span>
0020 <span class="comment">%   * vectorized:   vectorized algorithm, usually faster for large number</span>
0021 <span class="comment">%               of faces</span>
0022 <span class="comment">%   * auto:         (default) automatically choose the most appropriate</span>
0023 <span class="comment">%               between sequential and vectorized.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%   Example</span>
0026 <span class="comment">%     [V, F] = torusMesh();</span>
0027 <span class="comment">%     F2 = triangulateFaces(F);</span>
0028 <span class="comment">%     P = [10 20 30];</span>
0029 <span class="comment">%     [D, PROJ] = distancePointMesh(P, V, F2);</span>
0030 <span class="comment">%     figure; drawMesh(V, F)</span>
0031 <span class="comment">%     view(3); axis equal; lighting gouraud; light;</span>
0032 <span class="comment">%     drawPoint3d(P);</span>
0033 <span class="comment">%     drawPoint3d(PROJ, 'm*');</span>
0034 <span class="comment">%     drawEdge3d([P PROJ], 'linewidth', 2, 'color', 'b');</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   See also</span>
0037 <span class="comment">%     distancePointTriangle3d</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%   References</span>
0040 <span class="comment">%   * &quot;Distance Between Point and Triangle in 3D&quot;, David Eberly</span>
0041 <span class="comment">%       https://www.geometrictools.com/Documentation/DistancePoint3Triangle3.pdf</span>
0042 <span class="comment">%   * &quot;Distance between a point and a triangle in 3d&quot;, by Gwendolyn Fischer</span>
0043 <span class="comment">%       https://mathworks.com/matlabcentral/fileexchange/22857</span>
0044 <span class="comment">%   * &quot;Distance Between Point and Triangulated Surface&quot;, by Daniel Frisch</span>
0045 <span class="comment">%       https://www.mathworks.com/matlabcentral/fileexchange/52882</span>
0046 
0047 <span class="comment">% ------</span>
0048 <span class="comment">% Author: David Legland</span>
0049 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0050 <span class="comment">% Created: 2018-03-08, using Matlab 9.3.0.713579 (R2017b)</span>
0051 <span class="comment">% Copyright 2018-2024 INRA - Cepia Software Platform</span>
0052 
0053 <span class="comment">%% Parses input arguments</span>
0054 
0055 <span class="comment">% check the case of mesh given as structure</span>
0056 <span class="keyword">if</span> isstruct(vertices)
0057     faces = vertices.faces;
0058     vertices = vertices.vertices;
0059 <span class="keyword">end</span>
0060 
0061 <span class="comment">% default option</span>
0062 algo = <span class="string">'auto'</span>;
0063 
0064 <span class="comment">% check optional arguments</span>
0065 <span class="keyword">while</span> length(varargin) &gt; 1
0066     varName = varargin{1};
0067     <span class="keyword">if</span> ~ischar(varName)
0068         error(<span class="string">'Require options as parameter name-value pairs'</span>);
0069     <span class="keyword">end</span>
0070     
0071     <span class="keyword">if</span> strcmpi(varName, <span class="string">'algorithm'</span>)
0072         algo = varargin{2};
0073     <span class="keyword">else</span>
0074         error([<span class="string">'Unknown option name: '</span> varName]);
0075     <span class="keyword">end</span>
0076     
0077     varargin(1:2) = [];
0078 <span class="keyword">end</span>
0079 
0080 <span class="comment">% number of faces</span>
0081 nFaces = size(faces, 1);
0082 
0083 <span class="keyword">if</span> size(faces, 2) &gt; 3 || iscell(faces)
0084     faces = <a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a>(faces);
0085 <span class="keyword">end</span>
0086 
0087 <span class="comment">% If algorithm is chosen automatically, choose depending on face number</span>
0088 <span class="keyword">if</span> strcmpi(algo, <span class="string">'auto'</span>)
0089     <span class="keyword">if</span> size(faces, 1) &gt; 30
0090         algo = <span class="string">'vectorized'</span>;
0091     <span class="keyword">else</span>
0092         algo = <span class="string">'sequential'</span>;
0093     <span class="keyword">end</span>
0094 <span class="keyword">end</span>
0095 
0096 <span class="comment">% switch to vectorized algorithm if necessary</span>
0097 <span class="keyword">if</span> strcmpi(algo, <span class="string">'vectorized'</span>)
0098     <span class="keyword">if</span> nargout &gt; 1
0099         [dist, proj] = <a href="#_sub1" class="code" title="subfunction [dist, proj] = distancePointTrimesh_vectorized(point, vertices, faces)">distancePointTrimesh_vectorized</a>(points, vertices, faces);
0100     <span class="keyword">else</span>
0101         dist = <a href="#_sub1" class="code" title="subfunction [dist, proj] = distancePointTrimesh_vectorized(point, vertices, faces)">distancePointTrimesh_vectorized</a>(points, vertices, faces);
0102     <span class="keyword">end</span>
0103     <span class="keyword">return</span>;
0104 <span class="keyword">end</span>
0105 
0106 
0107 <span class="comment">%% Sequential algorithm</span>
0108 <span class="comment">% For each point, iterates over the triangular faces</span>
0109 
0110 <span class="comment">% allocate memory for result</span>
0111 nPoints = size(points, 1);
0112 dist = zeros(nPoints, 1);
0113 
0114 <span class="keyword">if</span> nargout &gt; 1
0115     proj = zeros(nPoints, 3);
0116 <span class="keyword">end</span>
0117 
0118 <span class="comment">% iterate over points</span>
0119 <span class="keyword">for</span> i = 1:nPoints
0120     <span class="comment">% % min distance and projection for current point</span>
0121     minDist = inf;
0122     projp = [0 0 0];
0123     
0124     <span class="comment">% iterate over faces</span>
0125     <span class="keyword">for</span> iFace = 1:nFaces
0126         <span class="comment">% create triange for current face</span>
0127         face = faces(iFace, :);
0128         triangle = vertices(face, :);
0129         
0130         [distf, projf] = <a href="../../matGeom/geom3d/distancePointTriangle3d.html" class="code" title="function [dist, proj] = distancePointTriangle3d(point, triangle)">distancePointTriangle3d</a>(points(i,:), triangle);
0131         
0132         <span class="keyword">if</span> distf &lt; minDist
0133             minDist = distf;
0134             projp = projf;
0135         <span class="keyword">end</span>
0136     <span class="keyword">end</span>
0137     
0138     dist(i) = minDist;
0139     <span class="keyword">if</span> nargout &gt; 1
0140         proj(i,:) = projp;
0141     <span class="keyword">end</span>
0142 <span class="keyword">end</span>
0143 <span class="keyword">end</span>
0144 
0145 <a name="_sub1" href="#_subfunctions" class="code">function [dist, proj] = distancePointTrimesh_vectorized(point, vertices, faces)</a>
0146 <span class="comment">%DISTANCEPOINTTRIMESH Vectorized version of the distancePointTrimesh function</span>
0147 <span class="comment">%</span>
0148 <span class="comment">%   output = distancePointTrimesh_vectorized(input)</span>
0149 <span class="comment">%</span>
0150 <span class="comment">%   This version is  vectorized over faces: for each query point, the</span>
0151 <span class="comment">%   minimum distance to each triangular face is computed in parallel.</span>
0152 <span class="comment">%   Then the minimum distance over faces is kept.</span>
0153 <span class="comment">%</span>
0154 <span class="comment">%   Example</span>
0155 <span class="comment">%   distancePointTrimesh</span>
0156 <span class="comment">%</span>
0157 
0158 <span class="comment">% ­­­­­‒­­­­‒­­­­‒­­­­‒­­­­‒­­­­‒­­­­­</span>
0159 <span class="comment">% Author: David Legland</span>
0160 <span class="comment">% e-mail: david.legland@inra.fr</span>
0161 <span class="comment">% Created: 2018-03-08, using Matlab 9.3.0.713579 (R2017b)</span>
0162 <span class="comment">% Copyright 2018 INRA - Cepia Software Platform</span>
0163 
0164 <span class="comment">% Regions are not numbered as in the original paper of D. Eberly to allow</span>
0165 <span class="comment">% automated computation of regions from the 3 conditions on lines.</span>
0166 <span class="comment">% Region indices are computed as follow:</span>
0167 <span class="comment">%   IND = b2 * 2^2 + b1 * 2 + b0</span>
0168 <span class="comment">% with:</span>
0169 <span class="comment">%   b0 = 1 if s &lt; 0, 0 otherwise</span>
0170 <span class="comment">%   b1 = 1 if t &lt; 0, 0 otherwise</span>
0171 <span class="comment">%   b2 = 1 if s+t &gt; 1, 0 otherwise</span>
0172 <span class="comment">% resulting in the following region indices:</span>
0173 <span class="comment">%        /\ t</span>
0174 <span class="comment">%        |</span>
0175 <span class="comment">%   \ R5 |</span>
0176 <span class="comment">%    \   |</span>
0177 <span class="comment">%     \  |</span>
0178 <span class="comment">%      \ |</span>
0179 <span class="comment">%       \| P3</span>
0180 <span class="comment">%        *</span>
0181 <span class="comment">%        |\</span>
0182 <span class="comment">%        | \</span>
0183 <span class="comment">%   R1   |  \   R4</span>
0184 <span class="comment">%        |   \</span>
0185 <span class="comment">%        | R0 \</span>
0186 <span class="comment">%        |     \</span>
0187 <span class="comment">%        | P1   \ P2</span>
0188 <span class="comment">%  ­­­­–­­­–­­­–­­­–­­­–­­­–*–­­­–­­­–­­­–­­­–­­­––*–­­­–­­­–­­­–­­­–­­­–&gt; s</span>
0189 <span class="comment">%        |        \</span>
0190 <span class="comment">%   R3   |   R2    \   R6</span>
0191 
0192 <span class="comment">% allocate memory for result</span>
0193 nPoints = size(point, 1);
0194 dist = zeros(nPoints, 1);
0195 proj = zeros(nPoints, 3);
0196 
0197 <span class="comment">% triangle origins and direction vectors</span>
0198 p1  = vertices(faces(:,1),:);
0199 v12 = vertices(faces(:,2),:) - p1;
0200 v13 = vertices(faces(:,3),:) - p1;
0201 
0202 <span class="comment">% identify coefficients of second order equation that do not depend on</span>
0203 <span class="comment">% query point</span>
0204 a = dot(v12, v12, 2);
0205 b = dot(v12, v13, 2);
0206 c = dot(v13, v13, 2);
0207 
0208 <span class="comment">% iterate on query points</span>
0209 <span class="keyword">for</span> i = 1:nPoints
0210     <span class="comment">% coefficients of second order equation that depend on query point</span>
0211     diffP = bsxfun(@minus, p1, point(i, :));
0212     d = dot(v12, diffP, 2);
0213     e = dot(v13, diffP, 2);
0214     
0215     <span class="comment">% compute position of projected point in the plane of the triangle</span>
0216     det = a .* c - b .* b;
0217     s   = b .* e - c .* d;
0218     t   = b .* d - a .* e;
0219     
0220     <span class="comment">% compute region index (one for each face)</span>
0221     regIndex = (s &lt; 0) + 2 * (t &lt; 0) + 4 * (s + t &gt; det);
0222     
0223     <span class="comment">% for each region, process all faces whose projection fall within it</span>
0224     
0225     <span class="comment">% region 0</span>
0226     <span class="comment">% the minimum distance occurs inside the triangle</span>
0227     inds = regIndex == 0;
0228     s(inds) = s(inds) ./ det(inds);
0229     t(inds) = t(inds) ./ det(inds);
0230     
0231 
0232     <span class="comment">% region 1 (formerly region 3)</span>
0233     <span class="comment">% The minimum distance must occur on the line s = 0</span>
0234     inds = find(regIndex == 1);
0235     s(inds) = 0;
0236     t(inds(e(inds) &gt;= 0)) = 0;
0237     
0238     inds2 = inds(e(inds) &lt; 0);
0239     bool3 = c(inds2) &lt;= -e(inds2);
0240     t(inds2(bool3)) = 1;
0241     inds3 = inds2(~bool3);
0242     t(inds3) = -e(inds3) ./ c(inds3);
0243     
0244     
0245     <span class="comment">% region 2 (formerly region 5)</span>
0246     <span class="comment">% The minimum distance must occur on the line t = 0</span>
0247     inds = find(regIndex == 2);
0248     t(inds) = 0;
0249     s(inds(d(inds) &gt;= 0)) = 0;
0250 
0251     inds2 = inds(d(inds) &lt; 0);
0252     bool3 = a(inds2) &lt;= -d(inds2);
0253     s(inds2(bool3)) = 1;
0254     inds3 = inds2(~bool3);
0255     s(inds3) = -d(inds3) ./ a(inds3);
0256 
0257 
0258     <span class="comment">% region 3 (formerly region 4)</span>
0259     <span class="comment">% The minimum distance must occur</span>
0260     <span class="comment">% * on the line t = 0</span>
0261     <span class="comment">% * on the line s = 0 with t &gt;= 0</span>
0262     <span class="comment">% * at the intersection of the two lines</span>
0263     inds = find(regIndex == 3);
0264     
0265     inds2 = inds(d(inds) &lt; 0);
0266     <span class="comment">% minimum on edge t = 0 with s &gt; 0.</span>
0267     t(inds2) = 0;
0268     bool3 = a(inds2) &lt;= -d(inds2);
0269     s(inds2(bool3)) = 1;
0270     inds3 = inds2(~bool3);
0271     s(inds3) = -d(inds3) ./ a(inds3);
0272       
0273     inds2 = inds(d(inds) &gt;= 0);
0274     <span class="comment">% minimum on edge s = 0</span>
0275     s(inds2) = 0;
0276     bool3 = e(inds2) &gt;= 0;
0277     t(inds2(bool3)) = 0;
0278     bool3 = e(inds2) &lt; 0 &amp; c(inds2) &lt;= -e(inds2);
0279     t(inds2(bool3)) = 1;
0280     bool3 = e(inds2) &lt; 0 &amp; c(inds2) &gt; -e(inds2);
0281     inds3 = inds2(bool3);
0282     t(inds3) = -e(inds3) ./ c(inds3);
0283     
0284 
0285     <span class="comment">% region 4 (formerly region 1)</span>
0286     <span class="comment">% The minimum distance must occur on the line s + t = 1</span>
0287     inds = find(regIndex == 4);
0288     numer = (c(inds) + e(inds)) - (b(inds) + d(inds));
0289     s(inds(numer &lt;= 0)) = 0;
0290     inds2 = inds(numer &gt; 0);
0291     numer = numer(numer &gt; 0);
0292     denom = a(inds2) - 2 * b(inds2) + c(inds2);
0293     s(inds2(numer &gt; denom)) = 1;
0294     bool3 = numer &lt;= denom;
0295     s(inds2(bool3)) = numer(bool3) ./ denom(bool3);
0296     t(inds) = 1 - s(inds);
0297 
0298 
0299     <span class="comment">% Region 5 (formerly region 2)</span>
0300     <span class="comment">% The minimum distance must occur:</span>
0301     <span class="comment">% * on the line s + t = 1</span>
0302     <span class="comment">% * on the line s = 0 with t &lt;= 1</span>
0303     <span class="comment">% * or at the intersection of the two (s=0; t=1)</span>
0304     inds = find(regIndex == 5);
0305     tmp0 = b(inds) + d(inds);
0306     tmp1 = c(inds) + e(inds);
0307     
0308     <span class="comment">% minimum on edge s+t = 1, with s &gt; 0</span>
0309     bool2 = tmp1 &gt; tmp0;
0310     inds2 = inds(bool2);
0311     numer = tmp1(bool2) - tmp0(bool2);
0312     denom = a(inds2) - 2 * b(inds2) + c(inds2);
0313     bool3 = numer &lt; denom;
0314     s(inds2(~bool3)) = 1;
0315     inds3 = inds2(bool3);
0316     s(inds3) = numer(bool3) ./ denom(bool3);
0317     t(inds2) = 1 - s(inds2);
0318     
0319     <span class="comment">% minimum on edge s = 0, with t &lt;= 1</span>
0320     inds2 = inds(~bool2);
0321     s(inds2) = 0;
0322     t(inds2(tmp1(~bool2) &lt;= 0)) = 1;
0323     t(inds2(tmp1(~bool2) &gt; 0 &amp; e(inds2) &gt;= 0)) = 0;
0324     inds3 = inds2(tmp1(~bool2) &gt; 0 &amp; e(inds2) &lt; 0);
0325     t(inds3) = -e(inds3) ./ c(inds3);
0326 
0327         
0328     <span class="comment">% region 6 (formerly region 6)</span>
0329     <span class="comment">% The minimum distance must occur</span>
0330     <span class="comment">% * on the line s + t = 1</span>
0331     <span class="comment">% * on the line t = 0, with s &lt;= 1</span>
0332     <span class="comment">% * at the intersection of the two lines (s=1; t=0)</span>
0333     inds = find(regIndex == 6);
0334     tmp0 = b(inds) + e(inds);
0335     tmp1 = a(inds) + d(inds);
0336     
0337     <span class="comment">% minimum on edge s+t=1, with t &gt; 0</span>
0338     bool2 = tmp1 &gt; tmp0;
0339     inds2 = inds(bool2);
0340     numer = tmp1(bool2) - tmp0(bool2);
0341     denom = a(inds2) - 2 * b(inds2) + c(inds2);
0342     bool3 = numer &lt;= denom;
0343     t(inds2(~bool3)) = 1;
0344     inds3 = inds2(bool3);
0345     t(inds3) = numer(bool3) ./ denom(bool3);
0346     s(inds2) = 1 - t(inds2);
0347 
0348     <span class="comment">% minimum on edge t = 0 with s &lt;= 1</span>
0349     inds2 = inds(~bool2);
0350     t(inds2) = 0;
0351     s(inds2(tmp1(~bool2) &lt;= 0)) = 1;
0352     s(inds2(tmp1(~bool2) &gt; 0 &amp; d(inds2) &gt;= 0)) = 0;
0353     inds3 = inds2(tmp1(~bool2) &gt; 0 &amp; d(inds2) &lt; 0);
0354     s(inds3) = -d(inds3) ./ a(inds3);
0355     
0356 
0357     <span class="comment">% compute coordinates of closest point on plane</span>
0358     projList = p1 + bsxfun(@times, s, v12) + bsxfun(@times, t, v13);
0359     
0360     <span class="comment">% squared distance between point and closest point on plane</span>
0361     [dist(i), ind] = min(sum((bsxfun(@minus, point(i,:), projList)).^2, 2));
0362 
0363     <span class="comment">% keep the valid projection</span>
0364     proj(i, :) = projList(ind,:);
0365 <span class="keyword">end</span>
0366 
0367 <span class="comment">% convert squared distance to distance</span>
0368 dist = sqrt(dist);
0369 
0370 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>