<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mergeCoplanarFaces</title>
  <meta name="keywords" content="mergeCoplanarFaces">
  <meta name="description" content="MERGECOPLANARFACES Merge coplanar faces of a polyhedral mesh.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">matGeom</a> &gt; <a href="index.html">meshes3d</a> &gt; mergeCoplanarFaces.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matGeom\meshes3d&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mergeCoplanarFaces
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MERGECOPLANARFACES Merge coplanar faces of a polyhedral mesh.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function varargout = mergeCoplanarFaces(nodes, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MERGECOPLANARFACES Merge coplanar faces of a polyhedral mesh.

   [NODES, FACES] = mergeCoplanarFaces(NODES, FACES)
   [NODES, EDGES, FACES] = mergeCoplanarFaces(NODES, EDGES, FACES)
   NODES is a set of 3D points (as a nNodes-by-3 array), 
   and FACES is one of:
   - a nFaces-by-X array containing vertex indices of each face, with each
   face having the same number of vertices,
   - a nFaces-by-1 cell array, each cell containing indices of a face.
   The function groups faces which are coplanar and contiguous, resulting
   in a &quot;lighter&quot; mesh. This can be useful for visualizing binary 3D
   images for example.

   FACES = mergeCoplanarFaces(..., PRECISION)
   Adjust the threshold for deciding if two faces are coplanar or
   parallel. Default value is 1e-5.

   Example
       [v, e, f] = createCube;
       f = triangulateFaces(f);
       figure; drawMesh(v, f); 
       view(3); axis equal tight;
       [v2, f2] = mergeCoplanarFaces(v, f);
       figure; drawMesh(v2, f2); 
       view(3); axis equal tight;

   See also
       meshes3d, <a href="drawMesh.html" class="code" title="function varargout = drawMesh(varargin)">drawMesh</a>, <a href="minConvexHull.html" class="code" title="function newFaces = minConvexHull(points, varargin)">minConvexHull</a>, <a href="triangulateFaces.html" class="code" title="function [tri, inds] = triangulateFaces(faces)">triangulateFaces</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../matGeom/geom3d/crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>	CROSSPRODUCT3D Vector cross product faster than inbuilt MATLAB cross.</li><li><a href="../../matGeom/geom3d/isCoplanar.html" class="code" title="function copl = isCoplanar(x,y,z,tol)">isCoplanar</a>	ISCOPLANAR Tests input points for coplanarity in 3-space.</li><li><a href="../../matGeom/geom3d/vectorNorm3d.html" class="code" title="function n = vectorNorm3d(v)">vectorNorm3d</a>	VECTORNORM3D Norm of a 3D vector or of set of 3D vectors.</li><li><a href="../../matGeom/graphs/grLabel.html" class="code" title="function labels = grLabel(nodes, edges)">grLabel</a>	GRLABEL Associate a label to each connected component of the graph.</li><li><a href="../../matGeom/graphs/graph2Contours.html" class="code" title="function varargout = graph2Contours(nodes, edges) %#ok<INUSL>">graph2Contours</a>	GRAPH2CONTOURS Convert a graph to a set of contour curves.</li><li><a href="meshFaceNormals.html" class="code" title="function normals = meshFaceNormals(varargin)">meshFaceNormals</a>	MESHFACENORMALS Compute normal vector of faces in a 3D mesh.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="steinerPolytope.html" class="code" title="function [vertices, faces] = steinerPolytope(vectors)">steinerPolytope</a>	STEINERPOLYTOPE Create a steiner polytope from a set of vectors.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = mergeCoplanarFaces(nodes, varargin)</a>
0002 <span class="comment">%MERGECOPLANARFACES Merge coplanar faces of a polyhedral mesh.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   [NODES, FACES] = mergeCoplanarFaces(NODES, FACES)</span>
0005 <span class="comment">%   [NODES, EDGES, FACES] = mergeCoplanarFaces(NODES, EDGES, FACES)</span>
0006 <span class="comment">%   NODES is a set of 3D points (as a nNodes-by-3 array),</span>
0007 <span class="comment">%   and FACES is one of:</span>
0008 <span class="comment">%   - a nFaces-by-X array containing vertex indices of each face, with each</span>
0009 <span class="comment">%   face having the same number of vertices,</span>
0010 <span class="comment">%   - a nFaces-by-1 cell array, each cell containing indices of a face.</span>
0011 <span class="comment">%   The function groups faces which are coplanar and contiguous, resulting</span>
0012 <span class="comment">%   in a &quot;lighter&quot; mesh. This can be useful for visualizing binary 3D</span>
0013 <span class="comment">%   images for example.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   FACES = mergeCoplanarFaces(..., PRECISION)</span>
0016 <span class="comment">%   Adjust the threshold for deciding if two faces are coplanar or</span>
0017 <span class="comment">%   parallel. Default value is 1e-5.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   Example</span>
0020 <span class="comment">%       [v, e, f] = createCube;</span>
0021 <span class="comment">%       f = triangulateFaces(f);</span>
0022 <span class="comment">%       figure; drawMesh(v, f);</span>
0023 <span class="comment">%       view(3); axis equal tight;</span>
0024 <span class="comment">%       [v2, f2] = mergeCoplanarFaces(v, f);</span>
0025 <span class="comment">%       figure; drawMesh(v2, f2);</span>
0026 <span class="comment">%       view(3); axis equal tight;</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   See also</span>
0029 <span class="comment">%       meshes3d, drawMesh, minConvexHull, triangulateFaces</span>
0030 <span class="comment">%</span>
0031 
0032 <span class="comment">% ------</span>
0033 <span class="comment">% Author: David Legland</span>
0034 <span class="comment">% E-mail: david.legland@inrae.fr</span>
0035 <span class="comment">% Created: 2006-07-05</span>
0036 <span class="comment">% Copyright 2006-2024 INRA - CEPIA Nantes - MIAJ (Jouy-en-Josas)</span>
0037 
0038 <span class="comment">%% Process input arguments</span>
0039 
0040 <span class="comment">% set up precision</span>
0041 acc = 1e-5;
0042 <span class="keyword">if</span> ~isempty(varargin)
0043     var = varargin{end};
0044     <span class="keyword">if</span> isscalar(var)
0045         acc = var;
0046         varargin(end) = [];
0047     <span class="keyword">end</span>
0048 <span class="keyword">end</span>
0049 
0050 <span class="comment">% extract faces and edges</span>
0051 <span class="keyword">if</span> isscalar(varargin)
0052     faces = varargin{1};
0053 <span class="keyword">else</span>
0054     faces = varargin{2};
0055 <span class="keyword">end</span>
0056 
0057 
0058 <span class="comment">%% Initialisations</span>
0059 
0060 <span class="comment">% number of faces</span>
0061 nNodes = size(nodes, 1);
0062 nFaces = size(faces, 1);
0063 
0064 <span class="comment">% compute number of vertices of each face</span>
0065 Fn = ones(nFaces, 1) * size(faces, 2);
0066 
0067 <span class="comment">% compute normal of each faces</span>
0068 normals = <a href="meshFaceNormals.html" class="code" title="function normals = meshFaceNormals(varargin)">meshFaceNormals</a>(nodes, faces);
0069 
0070 <span class="comment">% initialize empty faces and edges</span>
0071 faces2  = cell(0, 1);
0072 edges2  = zeros(0, 2);
0073 
0074 <span class="comment">% Processing flag for each face</span>
0075 <span class="comment">% 1: face to process, 0: already processed</span>
0076 <span class="comment">% in the beginning, every triangle face need to be processed</span>
0077 flag = ones(nFaces, 1);
0078 
0079 
0080 <span class="comment">%% Main iteration</span>
0081 
0082 <span class="comment">% iterate on each  face</span>
0083 <span class="keyword">for</span> iFace = 1:nFaces
0084     
0085     <span class="comment">% check if face was already performed</span>
0086     <span class="keyword">if</span> ~flag(iFace)
0087         <span class="keyword">continue</span>;
0088     <span class="keyword">end</span>
0089 
0090     <span class="comment">% indices of faces with same normal</span>
0091     ind = find(<a href="../../matGeom/geom3d/vectorNorm3d.html" class="code" title="function n = vectorNorm3d(v)">vectorNorm3d</a>(<a href="../../matGeom/geom3d/crossProduct3d.html" class="code" title="function c = crossProduct3d(a,b)">crossProduct3d</a>(normals(iFace, :), normals)) &lt; acc);
0092     
0093     <span class="comment">% keep only coplanar faces (test coplanarity of points in both face)</span>
0094     ind2 = false(size(ind));
0095     <span class="keyword">for</span> j = 1:length(ind)
0096         ind2(j) = <a href="../../matGeom/geom3d/isCoplanar.html" class="code" title="function copl = isCoplanar(x,y,z,tol)">isCoplanar</a>(nodes([faces(iFace,:) faces(ind(j),:)], :), acc);
0097     <span class="keyword">end</span>
0098     ind2 = ind(ind2);
0099     
0100     <span class="comment">% compute edges of all faces in the plane</span>
0101     planeEdges  = zeros(sum(Fn(ind2)), 2);
0102     pos = 1;
0103     <span class="keyword">for</span> i = 1:length(ind2)
0104         face = faces(ind2(i), :);
0105         faceEdges = sort([face' face([2:end 1])'], 2);
0106         planeEdges(pos:sum(Fn(ind2(1:i))), :) = faceEdges;
0107         pos = sum(Fn(ind2(1:i)))+1;
0108     <span class="keyword">end</span>
0109     planeEdges = unique(planeEdges, <span class="string">'rows'</span>);
0110     
0111     <span class="comment">% relabel plane edges</span>
0112     [planeNodes, I, J] = unique(planeEdges(:)); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0113     planeEdges2 = reshape(J, size(planeEdges));
0114     
0115     <span class="comment">% The set of coplanar faces may not necessarily form a single connected</span>
0116     <span class="comment">% component. The following computes label of each connected component.</span>
0117     component = <a href="../../matGeom/graphs/grLabel.html" class="code" title="function labels = grLabel(nodes, edges)">grLabel</a>(nodes(planeNodes, :), planeEdges2);
0118     
0119     <span class="comment">% compute degree (number of adjacent faces) of each edge.</span>
0120     Npe = size(planeEdges, 1);
0121     edgeDegrees = zeros(Npe, 1);
0122     <span class="keyword">for</span> i = 1:length(ind2)
0123         face = faces(ind2(i), :);
0124         faceEdges = sort([face' face([2:end 1])'], 2);
0125         <span class="keyword">for</span> j = 1:size(faceEdges, 1)
0126             indEdge = find(sum(ismember(planeEdges, faceEdges(j,:)),2)==2);
0127             edgeDegrees(indEdge) = edgeDegrees(indEdge)+1;
0128         <span class="keyword">end</span>
0129     <span class="keyword">end</span>
0130     
0131     <span class="comment">% extract unique edges and nodes of the plane</span>
0132     planeEdges  = planeEdges(edgeDegrees==1, :);
0133     planeEdges2 = planeEdges2(edgeDegrees==1, :);
0134     
0135     <span class="comment">% find connected component of each edge</span>
0136     planeEdgesComp = zeros(size(planeEdges, 1), 1);
0137     <span class="keyword">for</span> iEdge = 1:size(planeEdges, 1)
0138         planeEdgesComp(iEdge) = component(planeEdges2(iEdge, 1));
0139     <span class="keyword">end</span>
0140     
0141     <span class="comment">% iterate on connected faces</span>
0142     <span class="keyword">for</span> c = 1:max(component)
0143         
0144         <span class="comment">% convert to chains of nodes</span>
0145         loops = <a href="../../matGeom/graphs/graph2Contours.html" class="code" title="function varargout = graph2Contours(nodes, edges) %#ok<INUSL>">graph2Contours</a>(nodes, planeEdges(planeEdgesComp==c, :));
0146     
0147         <span class="comment">% add a simple Polygon for each loop</span>
0148         facePolygon = loops{1};
0149         <span class="keyword">for</span> l = 2:length(loops)
0150             facePolygon = [facePolygon, NaN, loops{l}]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0151         <span class="keyword">end</span>
0152         faces2{length(faces2)+1, 1}  = facePolygon;
0153     
0154         <span class="comment">% also add news edges</span>
0155         edges2 = unique([edges2; planeEdges], <span class="string">'rows'</span>);
0156     <span class="keyword">end</span>
0157     
0158     <span class="comment">% mark processed faces</span>
0159     flag(ind2) = 0;
0160 <span class="keyword">end</span>
0161 
0162 
0163 <span class="comment">%% Additional processing on nodes</span>
0164 
0165 <span class="comment">% select only nodes which appear in at least one edge</span>
0166 indNodes = unique(edges2(:));
0167 
0168 <span class="comment">% for each node, compute index of corresponding new node (or 0 if dropped)</span>
0169 refNodes = zeros(nNodes, 1);
0170 <span class="keyword">for</span> i = 1:length(indNodes)
0171     refNodes(indNodes(i)) = i;
0172 <span class="keyword">end</span>
0173 
0174 <span class="comment">% changes indices of nodes in edges2 array</span>
0175 <span class="keyword">for</span> i = 1:length(edges2(:))
0176     edges2(i) = refNodes(edges2(i));
0177 <span class="keyword">end</span>
0178 
0179 <span class="comment">% changes indices of nodes in faces2 array</span>
0180 <span class="keyword">for</span> iFace = 1:length(faces2)
0181     face = faces2{iFace};
0182     <span class="keyword">for</span> i = 1:length(face)
0183         <span class="keyword">if</span> ~isnan(face(i))
0184             face(i) = refNodes(face(i));
0185         <span class="keyword">end</span>
0186     <span class="keyword">end</span>
0187     faces2{iFace} = face;
0188 <span class="keyword">end</span>
0189 
0190 <span class="comment">% keep only boundary nodes</span>
0191 nodes2 = nodes(indNodes, :);
0192 
0193 
0194 <span class="comment">%% Process output arguments</span>
0195 
0196 <span class="keyword">if</span> nargout == 1
0197     varargout{1} = faces2;
0198 <span class="keyword">elseif</span> nargout == 2
0199     varargout{1} = nodes2;
0200     varargout{2} = faces2;
0201 <span class="keyword">elseif</span> nargout == 3
0202     varargout{1} = nodes2;
0203     varargout{2} = edges2;
0204     varargout{3} = faces2;
0205 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 21-Nov-2024 11:30:22 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>